<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://example.com">
  <title>JimmyTang&#39;Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JimmyTang&#39;Blog">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="JimmyTang&#39;Blog">
<meta property="og:locale">
<meta property="article:author" content="JimmyTang">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="JimmyTang&#39;Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="img/profile.jpg" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/"></a></h1>
		</hgroup>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="img/profile.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author"></h1>
			</hgroup>
			
			
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 50%">
				
				
					<li style="width: 50%"><a href="/">主页</a></li>
		        
					<li style="width: 50%"><a href="/">随笔</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-C++Primer-面向对象程序设计" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h1><p>核心思想：数据抽象、继承和动态绑定。</p>
<p>引用和指针的静态类型和动态类型不总是相同，这一点是C++支持多态的根本。</p>
<p>动态绑定只有通过指针或者引用调用虚函数时才会发生。</p>
<ul>
<li><h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;book, <span class="keyword">double</span> sales_price) : bookNo(book), price(sales_price) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回给定数量的书籍的销售总额，派生类负责改写并实现不同的计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n * sales_price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;   <span class="comment">//对析构函数进行动态绑定,基类通常都应该定义一个虚析构函数。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义派生类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_Quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Bulk_Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//覆盖基类的net_price函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> discount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>关于virtual虚函数，构造函数之外的任何非静态函数都可以是虚函数，包括<kbd>析构函数</kbd>,virtual只能出现在类内部声明语句而不能出现在类外部定义语句中。如果派生类没有覆盖基类中的某个虚函数，那么派生类就会直接继承基类中的版本。override显式地注明该函数覆盖了它继承的虚函数，放在常成员函数const、引用成员函数的引用限定符(&amp;,&amp;&amp;)之后。</p>
<ul>
<li>为什么派生类的对象能当成基类对象来使用呢？？</li>
<li>因为派生类对象中含有与其基类对应的组成成分，所以可以将基类的指针或者引用绑定到派生类对象上。</li>
</ul>
<p>派生类初始化过程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先初始化基类Quote部分，等到Quote构造函数函数体执行完后再初始化min_qty,discount这两顺序由在类体中声明的顺序决定。最后再执行空函数体。</span></span><br><span class="line">Bulk_Quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) : Quote(book, p), min_qty(qty), discount(dis) &#123; &#125; </span><br></pre></td></tr></table></figure>

<p><strong>继承中的静态成员</strong></p>
<p>若基类存在静态成员，在整个继承体系中只存在该成员的唯一实例。</p>
<p><strong>防止继承</strong></p>
<p><kbd>final</kbd>关键字</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="keyword">final</span> :</span> Base &#123; <span class="comment">//final放在派生列表之前</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型转换与继承</strong></p>
<p>基类的指针或者引用的静态类型可能与动态类型不一致，也就是基类指针引用可以指向派生类对象。但是基类的变量的静态类型和动态类型必须是一致的 。</p>
<p><font color=red>不存在基类向派生类的隐式转换。</font>可以有显式转换dynamic_cast和static_cast。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_Quote* d1 = &amp;base; <span class="comment">//错误，不能将基类转换成派生类</span></span><br><span class="line">Bulk_Quote&amp; d2 = base;  <span class="comment">//错误，同理</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//即使一个基类指针已经指向了派生类对象，也不能实现基类向派生类的转换</span></span><br><span class="line">Bulk_Quote bulk;</span><br><span class="line">Quote *item = &amp;bulk;</span><br><span class="line">Bulk_Quote *bp = item;  <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><font color=red>类对象之间不存在类型转换。</font></p>
<p>当用派生类对象初始化或者赋值基类对象时，只有派生类对象中的基类部分会被拷贝移动或者赋值，派生类的其他部分会被忽略掉。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_Quote bulk;</span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>; <span class="comment">//调用的是Quote::Quote(const Quote&amp;)构造函数。</span></span><br><span class="line">item = bulk;      <span class="comment">//调用的是Quote::operator = (const Quote&amp;)</span></span><br></pre></td></tr></table></figure>

<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><p>所有的虚函数必须有定义。</p>
<p>virtual关键字：指明派生类中的虚函数。</p>
<p>final关键字：指明后续的任何覆盖该函数的行为都是不允许的。</p>
<p>这两个关键字应出现在形参列表及尾置返回类型之后。</p>
<p>一般情况下，基类和派生类中的虚函数的默认实参最好保持一致。</p>
<p><strong>虚函数表的内容没有？？？</strong></p>
<p><strong>回避虚函数的机制</strong></p>
<p>可以使用位作用域运算符::指定执行虚函数的某个版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> undis = Base-&gt;Quote::net_price(<span class="number">42</span>);  <span class="comment">//指定调用基类的net_price</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么时候需要回避虚函数机制呢？？</p>
<p>通常是在派生类虚函数需要调用它所覆盖掉的基类版本虚函数时。<br>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则会在运行时被解析为对派生类版本虚函数的自身调用，从而导致无限递归。</p>
</blockquote>
<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p><strong>纯虚函数</strong></p>
<p>纯虚函数无需定义。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Disc_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Disc_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">                Quote(book, price), quantity(qty), discount(disc) &#123;&#125;</span><br><span class="line">    <span class="comment">//纯虚函数，=0只能出现在类内部声明处</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>含有纯虚函数的类叫做抽象类。抽象类不能直接定义对象，需要通过继承覆盖纯虚函数才行。</p>
<p>派生类只初始化它的直接基类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, <span class="built_in">std</span>::<span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">                    Disc_quote(book, price, qty, disc);</span><br><span class="line">    <span class="comment">//覆盖抽象基类的版本</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//此时的继承关系是：Quote-&gt;Disc_quote-&gt;Bulk_quote。</span></span><br><span class="line">Bulk_quote bq;</span><br></pre></td></tr></table></figure>
<p>此时定义一个Bulk_quote对象bq的过程是：</p>
<ul>
<li>Bulk_quote构造函数将实参传递给Disc_quote的构造函数，Disc_quote的构造函数将实参再传递给Quote的构造函数。</li>
<li>Quote构造函数先初始化bookNo和price成员，然后执行Quote构造函数的函数体。</li>
<li>执行完Quote构造函数体之后，运行Disc_quote的构造函数并初始化quantity和discount成员，之后执行Disc_quote构造函数体。</li>
<li>最后执行Bulk_quote的构造函数。</li>
</ul>
<h3 id="访问控制和继承"><a href="#访问控制和继承" class="headerlink" title="访问控制和继承"></a>访问控制和继承</h3><p><strong>保护成员</strong></p>
<ul>
<li>与私有成员类似，类对象不能访问受保护成员。</li>
<li>与共有成员类似，派生类的成员和友元可以访问到基类的受保护成员。</li>
<li>但是派生类的成员或者友元只能通过派生类对象来访问基类受保护的成员，不能通过基类对象来访问受保护成员。</li>
<li>同时，派生类成员不能访问基类的private成员。</li>
</ul>
<p><strong>共有、私有和受保护继承</strong></p>
<p>派生访问说明符的作用是：<strong>控制派生类用户对基类成员的访问权限</strong>。</p>
<p>派生类访问说明符对于派生类的成员和友元能否访问基类的成员没有影响。</p>
<ol>
<li><p>public继承</p>
<p>不改变基类成员的访问属性。</p>
<p>派生类内能访问基类的public、protected成员。</p>
<p>派生类对象能访问基类的public成员。</p>
</li>
<li><p>protected继承</p>
<p>基类中的public、protected成员在派生类中的访问属性变成protected。</p>
<p>派生类内能访问基类的public、protected成员。</p>
<p>派生类对象不能直接访问基类的所有成员，相当于基类的public成员变成了派生类的protected成员。</p>
<p>派生类的派生类内可以访问到基类的public、protected成员。</p>
</li>
<li><p>private继承</p>
<p>基类中的public和protected成员在派生类中的访问属性变成private。</p>
<p>派生类的派生类不能访问到基类的所有成员。</p>
</li>
</ol>
<p><strong>友元与继承</strong></p>
<p>友元关系不能传递，也不能继承。</p>
<p><strong>改变个别成员的可访问性</strong></p>
<p>使用using改变访问属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> n&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::size;  <span class="comment">//将private继承而来的size()访问属性变成public，原先是private的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;    <span class="comment">//将private继承而来的n访问属性变成public，原先是private的</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>默认的继承保护级别</strong></p>
<p><kbd>class</kbd>默认是私有继承，<kbd>struct</kbd>默认是共有继承。</p>
<p>class和struct的唯一区别就是<font color=red>成员访问说明符和派生访问说明符的默认属性</font>。</p>
<h3 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h3><p>派生类的作用域嵌套与基类的作用域之内。<font color=orange>派生类的成员会隐藏基类的同名成员，即使形参列表不一样也会隐藏</font>，因为C++中名字查找先于类型检查，也就是先检查成员名字，如果有相同名字就隐藏，还未轮到类型检查。<font color=red>这也就是为什么基类和派生类的虚函数必须要有相同的形参列表。</font></p>
<p>如果要使用基类的同名成员，可以使用作用域运算符::来调用被隐藏的成员。</p>
<h3 id="构造函数与拷贝控制"><a href="#构造函数与拷贝控制" class="headerlink" title="构造函数与拷贝控制"></a>构造函数与拷贝控制</h3><p><strong>虚析构函数</strong></p>
<p>基类通常应该定义一个虚析构函数。为什么呢？？</p>
<p>因为当基类指针指向派生类对象时，delete基类指针，如果析构函数不是虚函数，那么调用的是基类的析构函数（会产生未定义行为），但实际上应该执行的是派生类的析构函数，因为指针指向的是一个派生类的对象。所以析构函数需要是虚函数才会在运行时确定该执行基类的析构函数还是派生类的析构函数。  只要基类的析构函数是虚函数，就能保证delete基类指针时执行的是正确的析构函数。</p>
<p>如果一个类定义了析构函数，即使是以=default形式定义的，编译器也不会为这个类合成一定操作。</p>
<p>如果一个类定义了拷贝构造函数，编译器就不会合成移动构造函数。</p>
<p>如果需要使用移动操作，那么必须从基类开始逐一定义移动操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如Quote中定义了虚析构函数，那么就没有合成的移动操作，必须自己定义移动操作。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;   <span class="comment">//显式定义拷贝控制函数，逐一拷贝成员</span></span><br><span class="line">    Quote(Quote&amp;&amp;) = <span class="keyword">default</span>;        <span class="comment">//显式定义移动构造函数，逐一移动成员</span></span><br><span class="line">    Quote&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;  <span class="comment">//显式定义拷贝赋值运算符</span></span><br><span class="line">    Quote&amp; <span class="keyword">operator</span> = (Quote&amp;&amp;) = <span class="keyword">default</span>;    <span class="comment">//显式定义移动赋值运算符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>定义派生类的拷贝或移动构造函数</strong></p>
<p>若要正确地定义派生类的拷贝和移动构造函数，那么必须在派生类的构造函数初始化列表中显式地调用拷贝或移动构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span><span class="comment">/*...*/</span>&#125;;  <span class="comment">//基类中定义有了拷贝构造函数和移动构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    D(<span class="keyword">const</span> D&amp; d) : Base(d) , ..., &#123;&#125;  <span class="comment">//显式调用基类拷贝构造函数来拷贝基类中的成员。</span></span><br><span class="line">    <span class="comment">//显式调用基类移动构造函数来移动基类中的成员</span></span><br><span class="line">    D(D&amp;&amp; d) : Base(<span class="built_in">std</span>::move(d)) , ..., &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是这样的话，派生类的基类部分将会使用默认构造函数，派生类自己的部分使用拷贝构造函数</span></span><br><span class="line">    D(<span class="keyword">const</span> D&amp; d) : <span class="comment">/*初始化派生类数据成员*/</span> &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，派生类使用基类的默认构造函数初始化派生类对象的基类部分，如果想要拷贝或移动派生类，必须在派生类的拷贝或移动构造函数的初始化列表中显式地调用基类的拷贝或移动构造函数。</p>
</blockquote>
<p><strong>派生类的赋值运算符</strong></p>
<p>派生类的赋值运算符必须显式地为派生类的基类部分赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">D&amp; D::<span class="keyword">operator</span> = (<span class="keyword">const</span> D&amp; rhs)&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);   <span class="comment">//显式地为基类赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为派生类部分赋值</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>派生类析构函数</strong></p>
<p>派生类析构函数只负责销毁派生类分配的内存。</p>
<p>对象销毁顺序与生成顺序相反：先执行派生类的析构函数，再执行基类的析构函数，直到继承体系得顶端。</p>
<p><strong>在构造函数和析构函数中调用虚函数得情况</strong></p>
<p>如果构造函数或析构函数调用了某个虚函数，那么执行得是与构造函数或者析构函数所属类型相对应的虚函数版本。</p>
<p><strong>继承的构造函数</strong></p>
<p>实际上基类的构造函数是不能被继承的，所以准确来说构造函数并不是继承而来的。在派生类中调用基类的构造函数的方法是使用using语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote;  <span class="comment">//使Disc_quote构造函数在派生类中可见，这里是基类全部的构造函数，不止某一个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一些特点：</p>
<blockquote>
<p>基类的构造函数含有默认实参，那么派生类将获得多个构造函数，每个构造函数分别省略掉一个默认形参。<br>默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承而来的构造函数不会被视为用户定义的构造函数，也就是说一个类如果含有继承来的构造函数，那么它也将拥有一个合成的默认构造函数。</p>
</blockquote>
<h3 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h3><p>用容器可以存放继承体系中不同的对象，但是存的应该是<strong>基类的指针</strong>，而不是具体的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; basket;   <span class="comment">//存放指针的容器</span></span><br><span class="line">basket.push_back(make_shared&lt;Quote&gt;(<span class="string">&quot;0-000-1&quot;</span>, <span class="number">50</span>));</span><br><span class="line">basket.push_back(make_shared&lt;Bulk_quote&gt;(<span class="string">&quot;0-000-2&quot;</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">.25</span>));</span><br><span class="line"><span class="comment">//调用的是Quote的版本，因为basket存的元素类型是Quote</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; basket.back()-&gt;net_price(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>例子：定义basket类</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt; &amp;sale)</span></span>&#123;</span><br><span class="line">        item.insert(sale);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">total_receipt</span><span class="params">(<span class="built_in">std</span>::ostream&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//用于multiset中的元素排序</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt; &amp;lhs, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt; &amp;rhs)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs-&gt;isbn() &lt; rhs-&gt;isbn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt;, <span class="keyword">decltype</span>(compare)*&gt; items&#123;compare&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-泛型算法" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h1><p>一般情况下，算法不直接操作容器，而是遍历由两个迭代器指定的元素范围来进行操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">42</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> result = find(vec.cbegin(), vec.cend(), val); <span class="comment">//find返回指向匹配位置的迭代器，如果找不到，则返回尾后迭代器。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对于内置数组也能用泛型算法</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">20</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> val2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span>* r = find(begin(arr), end(arr), val2);</span><br><span class="line"><span class="comment">//标准库的begin和end返回指向数组首元素和尾元素之后位置的指针。</span></span><br></pre></td></tr></table></figure>
<p>@[toc]</p>
<h3 id="只读算法"><a href="#只读算法" class="headerlink" title="只读算法"></a>只读算法</h3><p>accumulate包含在numeric头文件中，计算指定范围内的和。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = accumulate(vec.cbegin(), vec.cend(), <span class="number">0</span>);<span class="comment">// 第三个参数的类型决定了使用的加号类型以及返回值的类型。</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;vs&#123;<span class="string">&quot;jack&quot;</span>, <span class="string">&quot;likes&quot;</span>, <span class="string">&quot;rose&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> s = accumulate(vs.cbegin(), vs.cend(), <span class="built_in">string</span>(<span class="string">&quot;&quot;</span>)); <span class="comment">//正确，因为string定义了+运算符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s = accumulate(vs.cbegin(), vs.cend(), <span class="string">&quot;&quot;</span>); <span class="comment">//错误const char*没有定义+运算符</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>操作两个序列的算法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//roster2的元素至少和roster1中元素一样多</span></span><br><span class="line">equal(roster1.cbegin(), roster1.cend(), roster2); <span class="comment">//两个容器类型可以不一样，元素类型也可以不一样。比如，vector&lt;string&gt;可以和list&lt;const char*&gt;，只要能用==来比较两个元素即可。 </span></span><br></pre></td></tr></table></figure>
<h3 id="写容器元素的算法"><a href="#写容器元素的算法" class="headerlink" title="写容器元素的算法"></a>写容器元素的算法</h3><p>算法不检查写操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec;</span><br><span class="line">fill_n(vec.begin(), vec.size(), <span class="number">1</span>); <span class="comment">//所有元素重置为1</span></span><br><span class="line"></span><br><span class="line">fill_n(dest, n, val); <span class="comment">//dest是指向某一元素的迭代器，n是整数，表示从dest开始，至少包含n个元素的这样一个范围。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，调用算法往容器中写入超过容量的元素的结果是未定义的！</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fill_n(vec.begin(), <span class="number">10</span>, <span class="number">1</span>); <span class="comment">//错误，试图往空vector写入10个元素</span></span><br></pre></td></tr></table></figure>

<p><strong>back_inserter</strong><br>确保算法有足够空间来容纳元素的方法就是使用插入迭代器。<br>使用插入迭代器赋值时，会将一个与赋值号=右侧相等的元素添加到容器中。<br>back_inserter定义在iterator中。接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器，当通过该迭代器进行赋值时，会调用push_back将指定值添加到容器中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it = back_inserter(vec);</span><br><span class="line">*it = <span class="number">42</span>; <span class="comment">//此时vec中有42</span></span><br></pre></td></tr></table></figure>
<p>还可以使用back_inserter来创建一个迭代器，作为算法的目的位置来使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vec &#123;<span class="number">10</span>, <span class="number">30</span>, <span class="number">28</span>, <span class="number">16</span>&#125;;</span><br><span class="line">fill_n(back_inserter(vec), <span class="number">2</span>, <span class="number">1</span>); <span class="comment">//此时vec=&#123;10, 30, 28, 16, 1, 1&#125; </span></span><br></pre></td></tr></table></figure>

<p><strong>copy算法</strong></p>
<p>传递给copy的目的序列至少要和输入序列一样大。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[]= &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(*a)]; <span class="comment">//a2和a一样大 sizeof(数组名)表示的是数组所占空间</span></span><br><span class="line"><span class="keyword">auto</span> ret = copy(begin(a), end(a), a2); <span class="comment">//copy返回的是目的迭代器递增后的值，此时ret指向a2尾元素之后的位置。</span></span><br></pre></td></tr></table></figure>

<p>有很多算法提供所谓的”拷贝”版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replace(ilst.begin(), ilst.end(), <span class="number">0</span>, <span class="number">42</span>); <span class="comment">//将ilst中等于0的元素替换成42</span></span><br><span class="line"><span class="comment">//其copy版本是</span></span><br><span class="line">replace_copy(ilst.begin(), ilst.end(), back_inserter(vec), <span class="number">0</span>, <span class="number">42</span>); <span class="comment">//调用后ilst并未改变。vec包含ilst的拷贝，只不过等于0的值都被替换成42了。</span></span><br></pre></td></tr></table></figure>

<p><strong>重排容器元素的算法</strong></p>
<p>例子：消除重复单词。使用unique标准库算法来重排vector</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">elimDups</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp;words)</span></span>&#123;</span><br><span class="line">    sort(words.begin(), words.end());</span><br><span class="line">    <span class="comment">//unique重排输入范围，使得每个单词只出现一次，排列在容器前部，返回指向不重复区域开始的迭代器。</span></span><br><span class="line">    <span class="keyword">auto</span> end_unique = unique(words.begin(), words.end());</span><br><span class="line">    <span class="comment">//删除后面的元素。因为算法不对容器进行操作，所以要调用容器erase操作进行删除</span></span><br><span class="line">    words.erase(end_unique, words.end());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h2><h3 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h3><p>谓词是一个可调用的表达式，分为一元谓词(unary predicate)和二元谓词(binary predicate)。<br>接受谓词的算法对输入序列中的元素调用谓词，因此元素类型必须能够转换为谓词的参数类型。可以将一个谓词传递给一个算法，使之按照谓词的操作来管理输入序列。<br>例如将sort按照字符串的长度来进行排列：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按长度由短到长排序</span></span><br><span class="line"></span><br><span class="line">sort(words.begin(), words.end(), isShorter);</span><br></pre></td></tr></table></figure>
<p>对于这个问题，如果我们希望相等长度的字符串的位置关系不变，即长度相等的在前面的字符串排序后依旧排在前面，那就需要用到stable_sort()算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elimDups(words); <span class="comment">//按字典序排序，且去除重复单词</span></span><br><span class="line">stable_sort(words.begin(), words.end(), isShorter); <span class="comment">//该排序算法是稳定的</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>一般有四种可调用对象：</p>
<ol>
<li>函数。</li>
<li>函数指针。</li>
<li>重载了函数调用运算符的类。</li>
<li>lambda表达式。</li>
</ol>
<p>lambda表达式具有一个返回类型、一个参数列表和一个函数体。<br>一般形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>] (prameter <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123;function body&#125;</span><br></pre></td></tr></table></figure>
<p>其中[capture list]是一个lambda所在函数中定义的局部变量的列表（通常为空）。<br>与普通函数不同的是，lambda表达式必须使用尾置返回。此外lambda的形参不能有默认参数。<br>可以忽略参数列表和返回类型，但必须包含捕获列表和函数体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//与普通函数调用方式相同</span></span><br></pre></td></tr></table></figure>
<p>使用lambda表达式来在vector中寻找第一个大于等于给定长度的元素。find_if()接受一对迭代器表示一个范围，第三个参数接受一个一元谓词，所以无法使用两个参数的isShorter来比较字符串是否大于某一长度。此时需要用到lambda表达式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz)</span></span>&#123;</span><br><span class="line">    elimDups(words.begin(); <span class="comment">//将words按照字典序排序，去除重复元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用lambda表达式,返回指向第一个长度不小于sz的元素位置的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a)&#123;<span class="keyword">return</span> a.size() &gt;= sz;&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>for_each算法</strong></p>
<p>for_each接受一个可调用对象，并对输入序列中每一个元素调用此对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz)</span></span>&#123;</span><br><span class="line">    elimDups(words.begin(); <span class="comment">//将words按照字典序排序，去除重复元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用lambda表达式,返回指向第一个长度不小于sz的元素位置的迭代器</span></span><br><span class="line">    <span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a)&#123;<span class="keyword">return</span> a.size() &gt;= sz;&#125;);</span><br><span class="line">    <span class="comment">//打印长度大于sz的每一个元素，因为words经过排序，所以迭代器wc后面的元素长度都大于等于sz</span></span><br><span class="line">    for_each(wc, words.end(), [](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)&#123;<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;&quot;</span>;&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>捕获列表为空，是因为只对lambda所在的函数中定义的非static变量使用列表，cout不是在biggies函数中定义的名字，只要biggies出现的作用域包含了cout，我们就可以使用cout。</p>
<p><font color=red>lambda捕获列表只作用于局部非static变量，可以直接使用局部static变量和所在函数之外声明的变量。</font></p>
<p><strong>值捕获</strong></p>
<p>值捕获的前提是变量可以拷贝。在lambda创建时拷贝而不是调用时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [v1]&#123;<span class="keyword">return</span> v1&#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//j=42,因为创建lambda时进行了拷贝。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>引用捕获</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;v1]&#123;<span class="keyword">return</span> v1&#125;; <span class="comment">//创建lambda</span></span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//执行lambda。此时j = 0，因为lambda返回的是v1所指向的对象的值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有些情况下参数是不能拷贝的，只能捕获引用，例如ostream、istream对象。以引用方式捕获一个变量时，必须保证lambda执行时该变量是存在的。</p>
<p><strong>隐式捕获</strong></p>
<p>可以在捕获列表中写=来表示值捕获，写&amp;来表示进行引用捕获。这样可以让编译器根据lambda体中的代码来推断使用的是哪些变量。<br>此外还可以混合使用显式捕获和隐式捕获,第一个元素必须是隐式捕获(=或者&amp;)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">biggies</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;words, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::size_type sz, ostream&amp; os = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//os隐式引用捕获，c显式值捕获</span></span><br><span class="line">    for_each(words.begin(), words.end(), [&amp;, c] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;os &lt;&lt; s &lt;&lt; c;&#125;);</span><br><span class="line">    <span class="comment">//os显式引用捕获，c隐式值捕获</span></span><br><span class="line">    for_each(words.begin(), words.end(), [=, &amp;os] (<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;os &lt;&lt; s &lt;&lt; c;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>可变lambda</strong></p>
<p>一般情况下，对于值被拷贝的变量，lambda不会改变其值。若希望改变一个被捕获变量的值，需在参数列表首加上mutable。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [v1] () <span class="keyword">mutable</span> &#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//此时j=43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是引用捕获的变量，能否修改依赖于此引用指向的是const类型对象还是非const类型的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;v1] &#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">//此时j=1，是0前置自增之后的返回值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指定lambda返回类型</strong></p>
<p>如果一个lambda体包含return之外的任意语句，则编译器假定其返回void。若要返回指定类型，则需要使用尾置返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>&#125;;</span><br><span class="line">transform(vi.begin(), vi.end(), vi.begin(), </span><br><span class="line">            [](<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123;<span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;); <span class="comment">//使用尾置返回来指定返回类型</span></span><br></pre></td></tr></table></figure>
<p>标准库函数transform接收3个迭代器和一个可调用对象。前两个迭代器表述输入范围，都三个表示目位置，算法对每个输入元素调用可调用对象。</p>
<p><strong>参数绑定</strong></p>
<p>一般情况下，可以用函数来代替lambda表达式。但是，对于捕获局部变量的lambda表达式，想用函数来替换就不是那么容易了。比如find_if算法只能接受一个一元谓词，而比较字符串长度的化需要传入字符串以及需要比较的长度，这样用函数来就完成不了，需要用lambda表达式来捕获一个局部变量来形成一个一元谓词。<br>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="built_in">string</span>::size_type sz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.size() &gt; sz;</span><br><span class="line">&#125; <span class="comment">//这个函数接受两个参数，所以不能用于find_if</span></span><br></pre></td></tr></table></figure>
<p>要使find_if能够实现返回大于给定长度的字符串的功能，一个方法是使用lambda表达式，另一个方法就是使用bind()函数进行参数绑定。<br>标准库bind函数定义在functional头文件中。它接受一个可调用对象，生成一个新的可调用对象。</p>
<p>一般的调用形式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list);</span><br></pre></td></tr></table></figure>
<p>arg_list中的参数可能包含形如_n的占位符，表示newCallable的参数，例如_1为newCallable的第一个参数，_2为newCallable的第二个参数。</p>
<p><strong>绑定check_size的sz参数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check6是一个可调用对象，接受一个string参数</span></span><br><span class="line"><span class="comment">//并用此string和6来调用check_size函数。</span></span><br><span class="line"><span class="keyword">auto</span> check6 = bind(check_size, _1, <span class="number">6</span>);</span><br><span class="line"><span class="comment">//占位符_1出现在参数列表的第一个位置，说明check6的第一个参数对应check_size的第一个参数，类型应该为string类型。</span></span><br></pre></td></tr></table></figure>
<p>使用bind可以将原来使用的基于lambda的版本转换成bind的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), [sz](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a)&#123;<span class="keyword">return</span> a.size() &gt; sz;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//转换成</span></span><br><span class="line"><span class="keyword">auto</span> wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz)); <span class="comment">//check_size定义如上</span></span><br></pre></td></tr></table></figure>
<p>其中占位符_，1、_2等定义在placeholders的命名空间中，使用前需声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::placeholders::_1;</span><br></pre></td></tr></table></figure>
<p><strong>绑定引用参数</strong><br>一般情况下，bind的那些不是占位符的参数被拷贝到bind返回的可调用对象中。如果希望传递给bind一个对象而又不拷贝它，就必须调用标准库的ref函数。ref返回一个对象，包含给定的引用，此对象可以拷贝。同理还有cref，都定义在头文件functional中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>
<h3 id="再探迭代器"><a href="#再探迭代器" class="headerlink" title="再探迭代器"></a>再探迭代器</h3><p>iterator中定义了以下四类迭代器。</p>
<ol>
<li>插入迭代器， 绑定到一个容器上，用来向容器插入元素。</li>
<li>流迭代器， 绑定到输入输出流上，用来遍历关联的IO流。</li>
<li>反向迭代器，除了forward_list之外标准库容器都有反向迭代器。</li>
<li>移动迭代器，不是用来拷贝其中元素，而是移动元素。</li>
</ol>
<p><strong>插入迭代器</strong></p>
<p>有3种类型：</p>
<ol>
<li>back_inserter 创建一个使用push_back的迭代器。</li>
<li>front_inserter 创建一个使用push_front的迭代器。</li>
<li>inserter 创建一个使用insert的迭代器。此函数接受第二个参数，是指向给定容器的迭代器，元素被插入到<font color=blue>给定迭代器所表示的元素之前。</font></li>
</ol>
<p>使用inserter(c, iter)时得到一个迭代器，使用它时会将元素插入到iter原来所指向的元素之前的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = inserter(c, iter); <span class="comment">//获取一个插入迭代器it</span></span><br><span class="line">*it = <span class="number">1</span>; </span><br><span class="line"><span class="comment">//效果等价于</span></span><br><span class="line">it = c.insert(it, <span class="number">1</span>);</span><br><span class="line">++it;</span><br></pre></td></tr></table></figure>
<p>front_inseerter 元素总是插入到第一个元素之前。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2, lst3;</span><br><span class="line"><span class="comment">//拷贝完成之后，lst2包含4 3 2 1</span></span><br><span class="line">copy(lst.cbegin(), lst.cend(), front_inserter(lst2));</span><br><span class="line"><span class="comment">//拷贝完成之后， lst3包含1 2 3 4</span></span><br><span class="line">copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));</span><br></pre></td></tr></table></figure>

<p><strong>iostream迭代器</strong></p>
<p><font color=blue>istream_iterator</font> 读取输入流。<br><font color=blue>ostream_iterator</font> 向一个输出流写数据。<br>istream_iterator操作<br>istream_iterator读取的类型必须定义了输入运算符&gt;&gt;。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">int_it</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">//初始化一个迭代器int_it，绑定到cin</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof; <span class="comment">//默认初始化，创建了一个尾后迭代器</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;a.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">istream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">str_it</span><span class="params">(in)</span></span>; <span class="comment">//将输入流迭代器关联到文件输入流对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//istream_iterator从标准输入读取数据，存入vector中</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; int_eof; <span class="comment">//istream_iterator尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span>(in_iter != int_eof)&#123;</span><br><span class="line">    vec.push_back(*in_iter++); <span class="comment">//后置自增运算符优先级高于解引用运算符。后置自增运算符&gt;前置自增运算符&gt;解引用运算符。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面写法等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in_iter(cin), eof;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>; <span class="comment">//从迭代器范围构造vector</span></span><br></pre></td></tr></table></figure>
<p>vector构造函数从cin中读取数据，直到遇到文件尾或者第一个不是int的数据为止。</p>
<table>
<thead>
<tr>
<th></th>
<th>istream_iterator操作</th>
</tr>
</thead>
<tbody><tr>
<td>istream_iterator<T> in(istream);</td>
<td>in从输入流读取类型为T的值</td>
</tr>
<tr>
<td>istream_iterator<T> end;</td>
<td>读取类型为T的值的istream_iterator迭代器，表示尾后位置。</td>
</tr>
<tr>
<td>in1 == in2; in1 != in2</td>
<td>in1和in2必须读取相同类型。如果都是尾后迭代器，或者绑定到相同的输入，则两者相等。</td>
</tr>
<tr>
<td>*in</td>
<td>返回从流中读取的值。</td>
</tr>
<tr>
<td>++in、in++</td>
<td>使用元素类型所定义的&gt;&gt;运算符从输入流中读取下一值。前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值(一个临时对象，只能用作右值)。</td>
</tr>
</tbody></table>
<p><strong>ostream_iterator操作</strong></p>
<p>可以对任何定义有输出运算符&lt;&lt;的类型定义ostream_iterator。必须将ostream_iterator绑定到一个指定的流，<font color=red>不允许空的或表示尾后迭代器的ostream_iterator。</font></p>
<table>
<thead>
<tr>
<th></th>
<th>ostream_iterator操作</th>
</tr>
</thead>
<tbody><tr>
<td>ostream_iterator<T> out(os);</td>
<td>out将类型为T的值写到输出流os。</td>
</tr>
<tr>
<td>ostream_iterator<T> out(os, d);</td>
<td>out将类型为T的值写到输出流中，每个值后面都输出一个d。d指向一个以空字符结尾的字符数组。</td>
</tr>
<tr>
<td>out = val;</td>
<td>用&lt;&lt;运算符将val写到out所绑定的ostream对象中。val的类型必须与out可写的类型兼容。</td>
</tr>
<tr>
<td>*out , ++out, out++</td>
<td>这些运算存在，但不对out做任何事情，每个运算符都返回out</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e: vec)&#123;</span><br><span class="line">    *out++ = e; <span class="comment">//将元素e写到cout</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实向out_iter赋值时，可以忽略*和++</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)&#123;</span><br><span class="line">    out_iter = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用流迭代器处理类类型</strong></p>
<p>只要类类型定义有&lt;&lt;，我们就可以为其定义ostream_iterator对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sales_item类定义有&lt;&lt;, &gt;&gt;</span></span><br><span class="line">istream_iterator&lt;Sales_item&gt; item_iter(cin), eof;</span><br><span class="line"><span class="function">ostream_iterator&lt;Sales_item&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">&quot;\n&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">Sales_item sum = *item_iter++;</span><br><span class="line"><span class="keyword">while</span>(item_iter != eof)&#123;</span><br><span class="line">    <span class="comment">//如果当前交易记录中有着相同的ISBN号</span></span><br><span class="line">    <span class="keyword">if</span>(item_iter-&gt;isbn() == sum.isbn())</span><br><span class="line">        sum += *item_iter++; <span class="comment">//将其加到sum中，并读取下一记录</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out_iter = sum; <span class="comment">//输出当前值</span></span><br><span class="line">        sum = *iyem_iter++; <span class="comment">//读取下一记录</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">out_iter = sum; <span class="comment">//打印最后一组记录的和</span></span><br></pre></td></tr></table></figure>

<p><strong>反向迭代器</strong></p>
<p>除了forward_list外，其他容器都支持反向迭代器。<font color=red>反向迭代器rbegin指向的是容器最后一个元素, rend指向容器首元素的前面一个位置。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = vec.rbegin(); iter != vec.rend(); ++iter)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter;  <span class="comment">//输出内容是4，3，2，1，1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反向迭代器支持自增、自减运算符。但是，流迭代器不支持递减运算。<br>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出line的最后一个逗号后面的单词</span></span><br><span class="line"><span class="built_in">string</span> line = &#123;<span class="string">&quot;FIRST,MIDDLE,LAST&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> rcomma = find(line.crbegin(), line.crend(), <span class="string">&#x27;,&#x27;</span>); <span class="comment">//返回指向最后一个逗号的反向迭代器</span></span><br><span class="line"><span class="comment">//输出的将是逆序的字符串TSAL，而我们想要的是LAST</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(line.crbegin(), rcomma) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用反向迭代器的base成员将反向迭代器转换成普通迭代器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">string</span>(rcomma.base(), line.cend()) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>rcomma指向最后一个逗号，而rcomma.base()指向最后一个逗号的后一个位置，要注意区分两者位置关系。</p>
<h3 id="泛型算法结构"><a href="#泛型算法结构" class="headerlink" title="泛型算法结构"></a>泛型算法结构</h3><p>对于算法要求的迭代器操作可以分为5个类别。</p>
<table>
<thead>
<tr>
<th></th>
<th>迭代器类别</th>
</tr>
</thead>
<tbody><tr>
<td>输入迭代器</td>
<td>只读不写，单遍扫描，只能递增</td>
</tr>
<tr>
<td>输出迭代器</td>
<td>只写不读，单遍扫描，只能递增</td>
</tr>
<tr>
<td>前向迭代器</td>
<td>可读写，多遍扫描，只能递增</td>
</tr>
<tr>
<td>双向迭代器</td>
<td>可读写，多遍扫描，可递增递减</td>
</tr>
<tr>
<td>随机访问迭代器</td>
<td>可读写，多遍扫描，支持全部迭代器运算</td>
</tr>
<tr>
<td>除输出迭代器之外，高层类别的迭代器支持底层类别的迭代器的所有操作。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>算法形参模式</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alg(beg, end, other args)</span><br><span class="line">alg(beg, end, dest, other args)</span><br><span class="line">alg(beg, end, beg2, other args)</span><br><span class="line">alg(beg, end, beg2, end2, other args)</span><br></pre></td></tr></table></figure>
<p>单独接受beg2的算法将beg2作为第二个输入范围中的首元素，所以第二个输入范围的大小至少和第一个输入范围大小一样。</p>
<p>一般来说，写到额外空间的算法的名字后面都有一个_copy。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">reverse(v.begin(), v.end()); </span><br><span class="line">reverse_copy(v.begin(), v.end(), back_inserter(v2));</span><br><span class="line"></span><br><span class="line">remove_if(v.begin(), v.end(), [] (<span class="keyword">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span>;&#125;); <span class="comment">//删除奇数元素</span></span><br><span class="line">remove_copy_if(v.begin(), v.end(), back_inserter(v2), [] (<span class="keyword">int</span> i) &#123;<span class="keyword">return</span> i % <span class="number">2</span>;&#125;);  <span class="comment">//将偶数元素拷贝到v2</span></span><br></pre></td></tr></table></figure>
<h3 id="特定容器算法"><a href="#特定容器算法" class="headerlink" title="特定容器算法"></a>特定容器算法</h3><p>通用版本的sort算法要求使用随机访问迭代器，所以不能用于list和forward_list。list提供双向迭代器，forward_list提供前向迭代器。<br><font color=red>对于链表类容器，应当优先使用成员函数版本的算法而不是通用算法。</font>因为链表成员函数算法通过改变链表元素间的连接来间接交换元素，而不是真正地交换元素位置，效率要高很多。</p>
<table>
<thead>
<tr>
<th>list和forward_list成员函数版本的算法</th>
<th>这些操作返回值都是void</th>
</tr>
</thead>
<tbody><tr>
<td>lst.merge(lst2)</td>
<td>将来自lst2的元素合并到lst中，lst和lst2都必须是有序的</td>
</tr>
<tr>
<td>lst.merge(lst2, comp)</td>
<td>元素将从lst2中删除。第一个版本使用 &lt; 运算符，第二个版本使用给定的比较操作。</td>
</tr>
<tr>
<td>lst.remove(val)</td>
<td>调用erase删除掉与给定值相等的==的每个元素</td>
</tr>
<tr>
<td>lst.remove_if(pred)</td>
<td>调用erase删除掉令一元谓词为真的每个元素</td>
</tr>
<tr>
<td>lst.reverse()</td>
<td>反转lst中元素的顺序</td>
</tr>
<tr>
<td>lst.sort()</td>
<td>用&lt; 排序元素</td>
</tr>
<tr>
<td>lst.sort(comp)</td>
<td>使用给定比较操作排序元素</td>
</tr>
<tr>
<td>lst.unique()</td>
<td>调用erase删除同一个值的连续拷贝</td>
</tr>
<tr>
<td>lst.unique()</td>
<td>调用erase删除使给定二元谓词为真的元素</td>
</tr>
<tr>
<td></td>
<td>list和forward_list的splice成员函数</td>
</tr>
<tr>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>lst.splice(args)或者flst.splice(args)</td>
<td></td>
</tr>
<tr>
<td>(p, lst2)</td>
<td>p是指向lst中元素的迭代器，或者flst的首前位置的迭代器。函数将lst2所有元素移动到lst中p之前的位置，或者是flst中p之后的位置，并将lst2元素删除。lst2必须与lst类型相同且不能是同一个链表。</td>
</tr>
<tr>
<td>(p, lst2, p2)</td>
<td>p2是指向lst2中的有效迭代器，将p2指向的元素移动到lst中，或者将p2之后的元素移动到flst中。</td>
</tr>
<tr>
<td>(p, lst2, b, e)</td>
<td>b,e必须是lst2的有效范围将给定范围的元素移动到lst或者flst。其中lst和lst2可以是相同的链表，但p不能在给定范围中。</td>
</tr>
</tbody></table>
<p>fighting!!!</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-重载运算与类型转换" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a>重载运算与类型转换</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>基本格式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 <span class="keyword">operator</span> 运算符 (参数列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载运算符参数数目与该运算符作用的运算对象个数一样，例如重载=运算符，其参数列表中的参数数目应该为2。<br>但是，如果重载运算符为类的成员函数，那么其左侧的运算对象会绑定到隐式的this指针上，所以成员函数运算符的参数个数比运算符操作对象个数少1个。</p>
<p><font color=red>重载的运算符的优先级与内置类型的对应运算符的优先级一致。</font></p>
<p><strong>定义为成员函数OR非成员函数？</strong></p>
<ul>
<li>赋值=、下标[]、函数调用()、成员访问运算符-&gt;必须是成员函数。</li>
<li>符合赋值运算符(+= -=…)一般是成员函数，但非必须。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，递增++、递减–、解引用*等一般应该是成员运算符。</li>
<li>具有对称性的运算符、如算术运算符、关系运算符、位运算符等应该是非成员运算符。</li>
</ul>
<h3 id="重载的例子"><a href="#重载的例子" class="headerlink" title="重载的例子"></a>重载的例子</h3><p><strong>输入输出运算符&gt;&gt; 和 &lt;&lt;</strong></p>
<p>一般来说，输入输出运算符的重载形式为：stream&amp; operator 输入输出流运算符 (流普通引用, 操作对象);</p>
<p><font color=red>输入输出运算符必须是非成员函数。</font>因为它的返回对象是一个流的引用而非自定义的类对象引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以Sales_data类为例</span></span><br><span class="line"><span class="function">ostream &amp;<span class="title">operator</span> <span class="params">(ostream&amp; os, <span class="keyword">const</span> Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">    os &lt;&lt; item.isbn() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">    &lt;&lt; item.revenue() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.avg_price();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">istream &amp;<span class="title">operator</span> <span class="params">(istream&amp; is, Sales_data &amp;item)</span></span>&#123; <span class="comment">//与&gt;&gt;不同，这里的第二个参数必须为非const得，因为读入会改变操作对象。</span></span><br><span class="line">    <span class="keyword">double</span> price;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span>(is)&#123;                                 <span class="comment">//检查输入是否成功</span></span><br><span class="line">        item.revenue = item.units.sold * price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        item = Sales_data();    <span class="comment">//输入失败，赋予默认构造得值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重载输入运算符与输出运算符的一个不同就是输入运算符需要确保输入操作是否成功。</p>
<p><strong>算数和关系运算符</strong></p>
<p>相等运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//还是以Sales_data为例</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> == (<span class="keyword">const</span> Sales_data &amp;rhs, <span class="keyword">const</span> Sales_data &amp;lhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn() &amp;&amp; lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一般情况下定义了==也应该定义！=</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> != (<span class="keyword">const</span> Sales_data &amp;rhs, <span class="keyword">const</span> Sales_data &amp;lhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关系运算符</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) : name(name), age(age) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; ( <span class="keyword">const</span> Person&amp; rhs);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> Person::<span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Person&amp; rhs)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;age &lt; rhs.age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">a</span><span class="params">(<span class="string">&quot;Jack&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">b</span><span class="params">(<span class="string">&quot;Rose&quot;</span>, <span class="number">22</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (a &lt; b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义一个关系运算符 &lt; 会使自定义类对象在调用标准库算法时很便利。</p>
<p>赋值运算符</p>
<p><font color=red>赋值运算符必须是成员函数。复合赋值运算符不一定必须是成员函数，但是为了与内置类型的复合赋值运算符保持一致，一般定义为成员函数。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从给定的初始化列表赋值</span></span><br><span class="line">Person&amp; Person::<span class="keyword">operator</span> = (<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)&#123;</span><br><span class="line">    <span class="comment">//alloc_n_copy分配内存空间和拷贝给定范围内的元素</span></span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(il.begin(), il.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果对象之前分配有内存，先释放它，Person类没有，所以不释放。</span></span><br><span class="line"></span><br><span class="line">    name = data.first;</span><br><span class="line">    age = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initializer_list<T>是一种模板类型，其中 的元素永远是常量值，无法改变。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">il.begin();  <span class="comment">//初始化列表首元素</span></span><br><span class="line">il.end();</span><br><span class="line">il.size();</span><br></pre></td></tr></table></figure>
<p><strong>下标运算符</strong></p>
<p><font color=red>下标运算符必须是成员函数。</font>为与原始下标保持一致，一般返回所访问元素的引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span> [](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> element[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一般来说定义常量版本和非常量版本</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span> [](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)&#123;</span><br><span class="line">        <span class="keyword">return</span> element[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>递增递减运算符</strong></p>
<ol>
<li><p>前置运算符与后置运算符的区别是，后置运算符的参数列表需要有一个int形参。</p>
</li>
<li><p>一般先定义前置运算符，之后在定义后置运算符时可以利用定义好的前置运算符进行递增或递减。</p>
</li>
<li><p>前置运算符返回该类型的引用，而后置运算符返回一个临时对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNumber</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    MyNumber(<span class="keyword">int</span> n) :num(n) &#123;&#125;</span><br><span class="line">    <span class="comment">//前置返回类型引用</span></span><br><span class="line">    MyNumber&amp; <span class="keyword">operator</span> ++()&#123;</span><br><span class="line">        ++num;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MyNumber&amp; <span class="keyword">operator</span> --()&#123;</span><br><span class="line">        --num;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后置返回该类型的临时对象，参数列表有int形参。</span></span><br><span class="line">    MyNumber <span class="keyword">operator</span> ++(<span class="keyword">int</span>)&#123;</span><br><span class="line">        MyNumber tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++num;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    MyNumber <span class="keyword">operator</span> --(<span class="keyword">int</span>)&#123;</span><br><span class="line">        MyNumber tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --num;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其实重载的运算符可以显式地调用，也就是以一般的函数形式进行调用，但是一般不这样用。</p>
</li>
</ol>
<p><strong>成员访问运算符</strong></p>
<ul>
<li>箭头运算符-&gt;必须是成员函数，解引用运算符一般也是成员函数。</li>
<li>重载的箭头运算符永远都是执行访问成员的操作，而重载的其他运算符可以执行与默认运算符不一样的操作。</li>
</ul>
<p><strong>重载函数调用运算符</strong></p>
<p>作用就是让类的对象像函数一样进行调用。<br>必须是成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AbsInt</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-100</span>;</span><br><span class="line">AbsInt <span class="built_in">abs</span>;</span><br><span class="line"><span class="keyword">int</span> a = <span class="built_in">abs</span>(i);</span><br></pre></td></tr></table></figure>
<p>如果一个类定义了函数调用运算符，那么这个类的对象一般称为<strong>函数对象</strong>。而函数对象通常可以作为泛型算法的实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs = &#123;<span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;Rose&quot;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    PrintString(ostream&amp; o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">&#x27; &#x27;</span>) : os(o), sep(c)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;</span><br><span class="line">    <span class="keyword">char</span> sep;</span><br><span class="line">&#125;;</span><br><span class="line">PrintString printer;</span><br><span class="line">printer(s);  <span class="comment">//cout中打印s，以空格为分隔符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用for_each算法，将vs中的字符逐一输出到cerr中，以换行符为分隔符。</span></span><br><span class="line">for_each(vs.begin(), vs.end(), PrintString(<span class="built_in">cerr</span>, <span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>lambda表达式是函数对象</strong></p>
<p>定义一个lambda表达式后，编译器其实将该表达式翻译成了一个<font color=red>未命名类的未命名对象</font>。也就是说该未命名的类重载了函数调用运算符 () 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), </span><br><span class="line">            [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b) &#123;<span class="keyword">return</span> a.size() &lt; b.size();&#125;);</span><br><span class="line"><span class="comment">//默认情况下lambda表达式不能该变它捕获的变量。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这里的lambda表达式类似于下面：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShorterString</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的stable_sort相当于：</span></span><br><span class="line">stable_sort(words.begin(), words.end(), ShorterString());</span><br><span class="line"><span class="comment">//stable_sort每次比较两个字符串时，会“调用”这个函数对象。</span></span><br></pre></td></tr></table></figure>

<p>还有，lambda表达式以<font color = orange>引用捕获变量</font>时，其产生的类中不会生成对应的数据成员。若是以<font color=orange>值捕获</font>方式捕获变量时，其生成的类中会生成对应的数据成员，同时创建构造函数以拷贝的值来初始化该数据成员。生成的类不含默认构造函数、赋值运算符以及默认析构函数，默认的拷贝构造函数/移动构造函数视捕获的数据成员类型而定。书本P574.</p>
<p><strong>标准库定义的函数对象</strong></p>
<p>定义在functional头文件中。<br>一般情况下能使用标准库的函数对象就尽量使用标准库的函数对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt; nameTable;</span><br><span class="line"><span class="comment">//错误，不能直接比较两个指针的地址，未定义错误。</span></span><br><span class="line">sort(nameTable.begin(), nameTable.end(), </span><br><span class="line">        [](<span class="built_in">string</span> *a, <span class="built_in">string</span> *b)&#123;<span class="keyword">return</span> a &lt; b;&#125;)</span><br><span class="line"><span class="comment">//正确，标准库规定指针的less是定义过的。</span></span><br><span class="line">sort(nameTable.begin(), nameTable.end(), less&lt;<span class="built_in">string</span>*&gt;());</span><br></pre></td></tr></table></figure>
<p>对于关联容器，因为关联容器使用less<key_type>来对元素排序，所以可以直接定义元素类型为指针的set或者map而无需声明less。</p>
<p><strong>可调用对象与function</strong></p>
<p>可调用对象包含：函数、函数指针、lambda表达式、bind创建的对象、重载了函数调用运算符的类。<br>不同的类型可能具有相同的调用形式。例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;<span class="keyword">return</span> i + j;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mod = [] (<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> i % j;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i / j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//他们的调用形式都是</span></span><br><span class="line"><span class="keyword">int</span> (<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用一个map来存储函数指针</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; binops;</span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>, add&#125;);    <span class="comment">//正确，add是一个正确类型的函数指针。</span></span><br><span class="line"><span class="comment">//错误， divide和mod的调用形式与add一样，但类型不是int(*)(int, int)</span></span><br><span class="line">binops.insert(&#123;<span class="string">&quot;/&quot;</span>, divide&#125;)</span><br></pre></td></tr></table></figure>

<p>解决方法就是用functional头文件中的function。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>, add&#125;);</span><br><span class="line">binops.insert(&#123;<span class="string">&quot;/&quot;</span>, divide()&#125;);  <span class="comment">//重载了()的函数对象</span></span><br><span class="line">binops.insert(&#123;<span class="string">&quot;%&quot;</span>, mod&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以这样调用，function类型重载了调用运算符</span></span><br><span class="line">binops[<span class="string">&quot;+&quot;</span>](<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">///调用add函数，输出3。</span></span><br></pre></td></tr></table></figure>

<p>重载的函数不能直接放入function中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载了add,无法区分</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>, add&#125;); <span class="comment">//错误，不能确定是那个add</span></span><br></pre></td></tr></table></figure>

<p>解决方法，可以用：</p>
<ol>
<li>函数指针。</li>
<li>lambda表达式</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;  <span class="comment">//指向的是第一个add。</span></span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>, fp&#125;);</span><br><span class="line"></span><br><span class="line">binops.insert(&#123;<span class="string">&quot;+&quot;</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)&#123;<span class="keyword">return</span> add(<span class="number">1</span>, <span class="number">2</span>)&#125;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h3><p>一个形参的非<kbd>explicit</kbd>的构造函数隐式地定义了一种从形参类型到该类类型的隐式转换规则。</p>
<p><strong>类型转换运算符</strong></p>
<ul>
<li>必须定义为成员函数。</li>
<li>没有返回类型。</li>
<li>形参列表必须为空。</li>
<li>通常应该是const成员函数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || i &gt; <span class="number">255</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> value;&#125;  <span class="comment">//定义了转换为int的类型转换运算符。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">3.14</span>;   <span class="comment">//先内置类型double转换成int，之后调用SmallInt(int)构造函数。</span></span><br><span class="line">si + <span class="number">3.14</span>;   <span class="comment">//int()先将si转换成int型，之后内置的Int型转换成double与3.14相加。</span></span><br></pre></td></tr></table></figure>
<p>因为类型转换是**<em>隐式**</em>进行的，无法给函数传递实参，所以也就形参列表就为空。<br>注意避免过度使用类型转换运算符。一般来说，类很少定义类型转换运算符，除了bool之外。</p>
<p>隐式的类型转换会存在意想不到的问题，所以引入了<strong>显式的类型转换运算符</strong>。也就是在转换运算符前加上explicit。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;  <span class="comment">//显式类型转换</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si;</span><br><span class="line"><span class="comment">//这种情况下，需要显式地声明类型转换才会进行类型的转换。</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;  <span class="comment">//显式地调用operator int()</span></span><br></pre></td></tr></table></figure>
<p>一般来说，显式声明的类型转换运算符需要显式地调用，只有一个例外：表达式被用作条件时，显式的类型转换将会被隐式地执行。</p>
<ol>
<li>在if、while以及do语句的条件部分。</li>
<li>for语句的条件表达式。</li>
<li>逻辑与或非(&amp;&amp;,||,!)。</li>
<li>条件运算符(? : )的条件部分。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (si &gt; <span class="number">10</span>)&#123;  <span class="comment">//si被隐式地转换成int型。</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于IO流，无论什么时候在条件中使用流，都会使用流定义的operator bool类型转换运算符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; i)&#123; ... &#125; <span class="comment">//cin将数据读入i并返回cin。这个时候cin就会隐式地执行operator bool将返回的cin转换成bool用于条件判断。</span></span><br></pre></td></tr></table></figure>
<p>而且一般来说， bool类型转换应该定义成explicit的，因为它一般只用在条件语句中。</p>
<p><strong>避免有二义性的类型转换</strong></p>
<p>不要定义多种从类型A到类型B的转换路径，一般只要一对一的转换，否则在类型转换时，编译器不知道调用哪种转换方式。(书本P584)</p>
<p><font color=red>总的来说，除了显式地定义向bool的转换之外，尽量避免定义类型转换函数和非显式的单形参的构造函数。</font></p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-动态内存" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><h2 id="C-内存分配模型"><a href="#C-内存分配模型" class="headerlink" title="C++内存分配模型"></a>C++内存分配模型</h2><p><strong>静态(全局)内存</strong>：存储局部static对象、类static数据成员、定义在任何函数之外的对象。static对象在使用之前分配内存，程序结束时销毁。</p>
<blockquote>
<p>内存在程序编译的时候已经分配好，运行期间都存在。</p>
</blockquote>
<p><strong>栈内存</strong>：存储定义在函数内的非static对象（局部非静态变量）。仅在定义的函数块运行时才存在。</p>
<blockquote>
<p>栈内存分配运算内置于指令集，效率高，但是容量有限。</p>
</blockquote>
<p>**堆内存(自由空间)**：程序运行时分配的对象，声明周期由程序来控制。</p>
<blockquote>
<p>动态内存分配。</p>
</blockquote>
<p><strong>常量区</strong>：存放常量字符串，程序结束时由系统释放。</p>
<p><strong>代码区</strong>：存放函数体(类成员函数和全局区)的2进制代码。</p>
<p><img src="https://img-blog.csdnimg.cn/2020061722333879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDMxMzk0MA==,size_16,color_FFFFFF,t_70#pic_center" alt="https://blog.csdn.net/cherrydreamsover/article/details/81627855"></p>
<h3 id="静态全局变量、全局变量、静态局部变量、局部变量的区别"><a href="#静态全局变量、全局变量、静态局部变量、局部变量的区别" class="headerlink" title="静态全局变量、全局变量、静态局部变量、局部变量的区别"></a>静态全局变量、全局变量、静态局部变量、局部变量的区别</h3><p><font color=red>静态全局变量、全局变量区别</font></p>
<ol>
<li>静态全局变量和全局变量都属于全局区(静态区)。</li>
<li>静态全局变量只在本文件中有效，而全局变量在其他文件中可以调用。也就是说在其他文件定义相同的全局变量名会出错。</li>
</ol>
<p><font color=red>静态局部变量、局部变量区别</font></p>
<ol>
<li>静态局部变量属于静态区，局部变量属于栈区。</li>
<li>静态局部变量在函数调用结束后不会被销毁，直到程序结束才销毁，别的函数无法调用该变量。</li>
<li>静态局部变量若没有初始化，则会被默认初始化为0，局部变量则会被随机初始化。</li>
<li>静态局部变量在编译期间只赋值一次，此后每次函数调用时，调用上次函数结束时的值。而局部变量每调用一次，赋值一次。<h2 id="直接管理内存"><a href="#直接管理内存" class="headerlink" title="直接管理内存"></a>直接管理内存</h2>直接使用new/delete的类不能使用类对象的拷贝、赋值和销毁的默认形式。<br>new分配的内存是无名的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br></pre></td></tr></table></figure>
默认情况下，动态分配的对象是<strong>默认初始化</strong>的，也就是内置类型的值是未定义的，类类型的对象将使用默认构造函数构造。<br>也可以通过在类型名后面加上空括号来使用<strong>值初始化</strong>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>(); <span class="comment">//值初始化，*p=0</span></span><br></pre></td></tr></table></figure>
可以使用auto来推导类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">obj</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="keyword">auto</span>(obj); <span class="comment">//此时p为string*</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a, b, c&#125;; <span class="comment">//错误，只能由单个初始化器</span></span><br></pre></td></tr></table></figure>
定位new<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//如果分配失败，抛出std::bad_alloc异常</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">//定位new,如果分配失败，返回空指针,bad_alloc和nothrow定义在头文件new中</span></span><br></pre></td></tr></table></figure>
关于数组<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>](); <span class="comment">//10个值初始化的int</span></span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure>
delete之后指针变成了悬空指针，在<font color=red>delete之后置为nullptr。</font></li>
</ol>
<h3 id="malloc-new、free-delete的区别"><a href="#malloc-new、free-delete的区别" class="headerlink" title="malloc/new、free/delete的区别"></a>malloc/new、free/delete的区别</h3><ol>
<li>new操作符在自由存储区为对象动态分配空间，malloc函数从堆区动态分配空间。关于自由存储区，可以是堆区，也可以是静态存储区，取决于operator new在哪里为对象分配内存。</li>
<li>new操作符分配内存成功后返回对象类型的指针，而malloc返回的是void*指针，需要强制转换成所需类型。分配类型失败时，new会返回bad_alloc异常，malloc返回NULL</li>
<li>malloc/free需要手动计算类型大小，而new/delete不需要。</li>
<li>malloc/free只是动态分配和释放空间，而new/delete还会调用构造函数和析构函数进行初始化和清理。</li>
</ol>
<h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>shared_ptr:允许多个指针同时指向同一个对象。<br>unique_ptr:只允许一个指针指向某一对象。<br>weak_ptr:弱引用，指向shared_ptr所管理的对象。<br>都定义在memory头文件中。</p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><table>
<thead>
<tr>
<th></th>
<th>shared_ptr特有操作</th>
</tr>
</thead>
<tbody><tr>
<td>make_shared<T> (args)</td>
<td>返回一个shared_ptr，指向一个动态分配的类型为T的对象，使用args初始化此对象。</td>
</tr>
<tr>
<td>shared_ptr<T>p (q)</td>
<td>p是shared_ptr q的拷贝：此操作会递增q中的计数器，q中的指针必须能转换成T*</td>
</tr>
<tr>
<td>p = q</td>
<td>shared_ptr所保存的指针必须能互相转换，此操作会递减p的引用计数，递增q的引用计数，若p的引用计数变为了0，则释放其管理的原来的内存。</td>
</tr>
<tr>
<td>p.use_count()</td>
<td>返回与p共享对象的智能指针个数，可能会很慢。</td>
</tr>
<tr>
<td>p.unique()</td>
<td>若p.use_count()为1返回true，否则返回false</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = make_shared&lt;<span class="keyword">int</span>&gt; (<span class="number">42</span>); <span class="comment">//创建一个指向442的shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p2 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="keyword">auto</span> p3 = make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;();</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p4</span><span class="params">(p3)</span></span>; <span class="comment">//p3p4指向相同对象</span></span><br></pre></td></tr></table></figure>
<p>可以使用make_shared标准库函数来创建一个shared_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt;sp = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">//sp指向一个值为cccccccccc的string</span></span><br><span class="line"><span class="comment">//sp2指向一个值初始化的int，即值为0</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;sp2 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<p>shared_ptr只有在引用计数为0时才会销毁其所指向的对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//factory返回一个shared_ptr，指向一个动态分配的对象</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">factory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//一些操作</span></span><br><span class="line">    <span class="keyword">return</span> make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_factory</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p = factory();</span><br><span class="line">    <span class="comment">//使用p</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="comment">//p离开函数作用域，引用计数变为0，所指向的内存的被释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">use_factory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> p; <span class="comment">//返回p时，会递增引用计数</span></span><br><span class="line">&#125; <span class="comment">//p离开了作用域，但是所指向的内存没有被释放。</span></span><br></pre></td></tr></table></figure>
<p><strong>shared_ptr和new的结合使用</strong><br>接受指针参数的智能指针的构造函数是explicit的，也就是说不能将一个内置指针隐式转换成一个智能指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">//错误，不能使用赋值初始化</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;  <span class="comment">//正确，直接初始化</span></span><br></pre></td></tr></table></figure>
<p><strong>不要混合使用智能指针和内置指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr)</span></span>&#123; <span class="comment">//参数是传值方式，也就是调用时实参会被拷贝，引用计数会增加</span></span><br><span class="line">    <span class="comment">//使用ptr</span></span><br><span class="line">&#125;   <span class="comment">//ptr离开作用域，引用计数减一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//正确使用方法，传递一个shared_ptr</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">process(p); <span class="comment">//正确，拷贝p会增加它的引用计数，在process内的引用计数至少为2</span></span><br><span class="line"><span class="keyword">int</span> i = *p;  <span class="comment">//正确， 引用计数至少为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//错误用法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>*<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;</span><br><span class="line">process(x); <span class="comment">//错误，不能将一个int*转换成shared_ptr&lt;int&gt;</span></span><br><span class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(x));  <span class="comment">//可以传递，但是函数执行完后x所指向的内存会被释放</span></span><br><span class="line"><span class="keyword">int</span> j = *x; <span class="comment">//错误，此时x指向的内存已被释放。</span></span><br></pre></td></tr></table></figure>
<p><strong>不要使用get来初始化智能指针或者为智能指针赋值</strong><br>get()返回一个指向智能指针管理对象的内置指针。<br>使用get返回指针的代码不能delete此指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="keyword">int</span> *p = sp.get(); <span class="comment">//正确</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//两个独立的shared_ptr指向相同的内存，这两个shared_ptr的引用计数都是1，该程序块内的shared_ptr失效后会销毁其所指向的对象。</span></span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">q</span><span class="params">(p)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> foo = *sp; <span class="comment">//错误，此时sp所指向的内存已被释放</span></span><br></pre></td></tr></table></figure>
<p>reset()操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">sp.reset(); <span class="comment">//此时sp的引用计数为0，会释放其所指向的对象</span></span><br><span class="line">sp.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>)); <span class="comment">//sp指向一个新的值为1024的int对象</span></span><br></pre></td></tr></table></figure>

<p>使用智能指针，即使程序出现异常提前结束，智能指针也能保证正确地释放指针指向的内存。而内置指针无法实现这一点。</p>
<p><strong>注意陷阱</strong></p>
<blockquote>
<ol>
<li>不要使用相同的内置指针<strong>值初始化</strong>(或者reset)多个智能指针。因为这样其中某一个智能指针失效后会销毁所指向的对象，从而造成另一个智能指针指向的对象不存在了。</li>
<li>不要delete get()返回的指针。</li>
<li>不要用get()初始化或者reset另一智能指针。</li>
<li>如果智能指针管理的资源不是new分配的内存，需要传递一个删除器。</li>
<li>记住，使用get()返回的指针，在最后一个对应的智能指针被销毁后，返回的指针就无效了。</li>
</ol>
</blockquote>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>某个时刻只能有一个unique_ptr指向一个给定对象，不支持普通的拷贝和赋值操作。<br>初始化unique_ptr必须使用<strong>直接初始化</strong>形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">up2</span> <span class="params">(up)</span></span>; <span class="comment">//错误。不支持拷贝</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up3 = up; <span class="comment">//错误，不支持赋值</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>unique_ptr操作</th>
</tr>
</thead>
<tbody><tr>
<td>unique_ptr&lt;T, D&gt; u1;</td>
<td>空的unique_ptr，会使用类型为D的可调用对象来释放它所指向空间。D默认为delete操作符</td>
</tr>
<tr>
<td>unique_ptr&lt;T, D&gt; u1 (d);</td>
<td>空unique_ptr,调用类型为D的对象d来代替delete</td>
</tr>
<tr>
<td>u = nullptr;</td>
<td>释放u指向的对象，将u置空</td>
</tr>
<tr>
<td>u.release();</td>
<td>u放弃对指针的控制权，返回所指向的指针，并置空u</td>
</tr>
<tr>
<td>u.reset();</td>
<td>释放u所指向的对象</td>
</tr>
<tr>
<td>u.reset(q);</td>
<td>令u指向内置指针q，否则置空u</td>
</tr>
<tr>
<td>release()返回unique_ptr当前保存的指针并将其置为空，常用来初始化或给另一智能指针赋值。</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hi&quot;</span>))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p2</span> <span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;jack&quot;</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将p1的所有权转移给p2</span></span><br><span class="line">p2.reset(p1.release());</span><br></pre></td></tr></table></figure>
<p>唯一一个可以拷贝unique_ptr的例子就是从函数返回一个unique_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样也行</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(p)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(p))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>auto_ptr是一个早期版本的智能指针，具备部分unique_ptr功能，但已被废弃，尽量不要使用。</p>
</blockquote>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr是一种不控制所指向对象生命周期的智能指针，指向一个由shared_ptr管理的对象。将一个weak_ptr绑定到一个shared_ptr上不会改变shared_ptr的引用计数。<br>不能直接使用weak_ptr访问所指向的对象，而需要使用lock()成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">wkp</span> <span class="params">(p)</span></span>; <span class="comment">//直接初始化wkp</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> mp = wkp.lock(); <span class="comment">//mp指向wkp所指向的对象。</span></span><br></pre></td></tr></table></figure>
<h3 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h3><p>关于动态数组，使用new T[]分配返回的并不是一个数组，而是一个指向数组元素类型的指针。动态数组并不是数组类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> dp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]; <span class="comment">//10个int的数组，返回指向首元素的指针</span></span><br><span class="line"><span class="keyword">auto</span> ds = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]; <span class="comment">//同理</span></span><br><span class="line"><span class="keyword">auto</span> de = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]; <span class="comment">//动态分配一个空的数组是合法的，但是不能解引用</span></span><br><span class="line"><span class="keyword">delete</span> [] dp;</span><br><span class="line"><span class="keyword">delete</span> [] ds; <span class="comment">//释放动态数组空间，数组元素按逆序销毁。</span></span><br><span class="line"><span class="keyword">delete</span> [] de;</span><br></pre></td></tr></table></figure>
<p>标准库提供了一个可以管理new分配的动态数组的unique_ptr。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;int[]&gt; up (new int[10]);</span><br><span class="line">up.release(); <span class="comment">//自动调用delete[]销毁指针</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>指向数组的unique_ptr的操作</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>指向数组的unique_ptr不支持成员访问运算符(.和-&gt;)</td>
</tr>
<tr>
<td>unique_ptr&lt;T[]&gt; u;</td>
<td>u可以指向一个动态分配的数组</td>
</tr>
<tr>
<td>unique_ptr&lt;T[]&gt; u(q);</td>
<td>u指向内置指针所指向的动态数组</td>
</tr>
<tr>
<td>u[i]</td>
<td>返回u拥有的数组中的第i个元素。</td>
</tr>
</tbody></table>
<p>shared_ptr默认不支持管理动态数组，如果想使用shared_ptr来管理动态数组，必须提供自己的删除器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123;<span class="keyword">delete</span> [] p;&#125;)</span></span>;</span><br><span class="line">sp.reset(); <span class="comment">//调用lambda表达式delete[]数组</span></span><br></pre></td></tr></table></figure>

<h3 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h3><p>使用allocator类将内存的分配和对象的构造分离开来。<br>可以在分配的内存上按需构造对象，提高效率。<br>如果不使用allocator，没有默认构造函数的类就无法使用动态分配数组了。</p>
<table>
<thead>
<tr>
<th></th>
<th>allocator类及其算法</th>
</tr>
</thead>
<tbody><tr>
<td>allocator<T> a;</td>
<td>定义allocator对象a，可以为类型T的对象分配内存</td>
</tr>
<tr>
<td>a.allocator(n);</td>
<td>分配一个保存n个类型为T的对象的未构造内存</td>
</tr>
<tr>
<td>a.construct(p, args);</td>
<td>p必须是指向类型为T*的未构造的内存，args被传递给类型为T的构造函数，用于在内存中构造对象。</td>
</tr>
<tr>
<td>a.destroy(p);</td>
<td>对p指向的对象执行析构函数。</td>
</tr>
<tr>
<td>a.deallocate(p, n);</td>
<td>释放从T* p所指向的位置开始的n个类型为T的对象，p必须是由allocator返回的指针，n必须是创建时的大小。在deallocate之前，内存中的对象必须先被destroy。</td>
</tr>
</tbody></table>
<p>allocator分配的内存是原始的，未构造的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc;</span><br><span class="line"><span class="keyword">auto</span> p = alloc.allocate(<span class="number">10</span>); <span class="comment">//分配10个未初始化的string</span></span><br><span class="line"><span class="keyword">auto</span> q = p; <span class="comment">//q指向最后构造的元素之后的位置</span></span><br><span class="line">alloc.construct(q++); <span class="comment">//q为空字符串</span></span><br><span class="line">alloc.construct(q++, <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>); <span class="comment">//*q为cccccccccc</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//正确，因为p所指向的内存已有对象</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 错误，q指向未构造的内存，因为q++指向下一个未构造的内存了。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q != p)&#123;</span><br><span class="line">    alloc.destory(--q); <span class="comment">//销毁q指向的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//之后可以将分配的内存释放掉</span></span><br><span class="line">alloc.deallocate(p, <span class="number">10</span>); <span class="comment">//之所以是10是因为deallocate的大小必须和allocate的大小一致</span></span><br></pre></td></tr></table></figure>

<h3 id="拷贝和填充未初始化内存的算法"><a href="#拷贝和填充未初始化内存的算法" class="headerlink" title="拷贝和填充未初始化内存的算法"></a>拷贝和填充未初始化内存的算法</h3><p>如果觉得向上面一个一个construct比较麻烦，可以使用标准库的拷贝填充算法。</p>
<table>
<thead>
<tr>
<th></th>
<th>allocator拷贝填充算法</th>
</tr>
</thead>
<tbody><tr>
<td>uninitialized_copy(b, e, b2);</td>
<td>从迭代器b和e指出的输入范围中<strong>拷贝</strong>元素到迭代器b2指定的未构造的原始内存中，b2指向的内存必须足够大。</td>
</tr>
<tr>
<td>uninitialized_copy_n(b, n, b2);</td>
<td>从迭代器b开始，拷贝n个元素到迭代器b2指向的原始内存中。</td>
</tr>
<tr>
<td>uninitialized_fill(b, e, t);</td>
<td>在迭代器b,e指定的范围内创建对象，对象的值均为t的拷贝。</td>
</tr>
<tr>
<td>uninitialized_fill_n(b, n, t);</td>
<td>从迭代器b指向的内存开始创建n个对象。其值为t</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向一个分配大小为vi两倍的内存</span></span><br><span class="line"><span class="keyword">auto</span> p = alloc.allocate(vi.size() * <span class="number">2</span>);</span><br><span class="line"><span class="comment">//将vi中的元素拷贝到p指向的内存中， 返回的q指向最后一个构造的对象的后一个位置</span></span><br><span class="line"><span class="keyword">auto</span> q = uninitialized_copy(vi.begin(), vi.end(), p); </span><br><span class="line">uninitialized_fill_n(q, vi,size(), <span class="number">42</span>); <span class="comment">//将剩余的内存全部初始化为42</span></span><br></pre></td></tr></table></figure>


      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-拷贝控制" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h1><h3 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h3><p>本章的主要内容是类中的5个函数：</p>
<ul>
<li>拷贝构造函数 (copy constructor)</li>
<li>拷贝赋值运算符 (copy-assignment operator)</li>
<li>移动构造函数 (move constructor)</li>
<li>移动赋值运算符 (move-assignment operator)</li>
<li>析构函数 (destructor)<h3 id="拷贝、赋值和销毁"><a href="#拷贝、赋值和销毁" class="headerlink" title="拷贝、赋值和销毁"></a>拷贝、赋值和销毁</h3></li>
</ul>
<p><strong>拷贝构造函数</strong></p>
<p>拷贝构造函数第一个参数必须是引用类型，且不应该是explicit的。</p>
<blockquote>
<p><font color=blue>为什么参数必须是引用类型呢？</font></p>
<p>因为如果拷贝构造函数形参不是引用的话，在实参向形参传值的时候要进行拷贝，这样就会调用拷贝构造函数，形成递归调用，无限循环。</p>
</blockquote>
<p>拷贝初始化=和直接初始化的区别：</p>
<p>直接初始化就是普通的函数调用，使用与给定初始化参数最匹配的构造函数。<br>拷贝初始化一般使用拷贝构造函数来完成，但是如果一个类定义有移动构造函数且参数是一个右值，那么拷贝初始化调用的则是移动构造函数。</p>
<ul>
<li>拷贝初始化的常见形式</li>
<li>直接使用=定义变量。</li>
<li>将一个对象作为实参传递给非引用类型的形参。</li>
<li>从一个返回类型为非引用类型的函数返回一个对象。</li>
<li>花括号初始化列表初始化一个数组或者聚合类的成员。</li>
</ul>
<blockquote>
<p>练习13.4<br>假定Point是一个类类型，有一个public的拷贝构造函数，指出下面程序中那些地方使用了拷贝构造函数？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Point global;</span><br><span class="line"><span class="function">Point <span class="title">foo_bar</span><span class="params">(Point arg)</span></span>&#123; <span class="comment">//1形参拷贝</span></span><br><span class="line">  Point local = arg, *heap = <span class="keyword">new</span> Point(global); <span class="comment">//2: Point local = arg,  3: Point *heap = new Point(global)</span></span><br><span class="line">  *heap = local; <span class="comment">//这是赋值</span></span><br><span class="line">  Point pa[<span class="number">4</span>] = &#123;local, *heap&#125;;  <span class="comment">// 4, 5</span></span><br><span class="line">  <span class="keyword">return</span> *heap; <span class="comment">//6</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>练习13.5 给定下面一个框架类，编写一个拷贝构造函数。应动态分配一个新的string，并将对象拷贝到ps指向的位置，而不是拷贝ps的值。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>：</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    HasPtr(HasPtr&amp; origin);</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"> <span class="comment">//将origin的ps指向的对象拷贝到新的ps ，注意，获取一个实例的成员指针指向的对象，使用*instance.ptr</span></span><br><span class="line">HasPtr::HasPtr(HasPtr&amp; origin) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*origin.ps)), i(origin.i) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拷贝赋值运算符</strong></p>
<p>重载赋值运算符。某些运算符，包括赋值运算符，必须声明为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的this指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Foo&amp; rhs); <span class="comment">//赋值运算符</span></span><br><span class="line">  <span class="comment">//。。。。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>赋值运算符返回值类型为什么是引用呢？<br>书上说是为了与内置类型的赋值运算符保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。</p>
</blockquote>
<p><strong>析构函数</strong></p>
<p>负责释放对象的资源，就是销毁对象的非static数据成员。没有返回值，没有参数，所以不能重载，也就是说<font color=red>一个类只有一个析构函数。</font></p>
<p>构造函数中，类成员的初始化是在执行函数体之前完成的，且成员的初始化顺序按照在类中出现的先后顺序进行初始化。</p>
<p>而在析构函数中，先执行析构函数体，再销毁成员，按成员的初始化顺序逆序销毁。其实这样很有道理，有时候需要先在析构函数体中手动释放指针等指向的内存，执行完函数体后才销毁指针等成员。</p>
<p><strong>三/五法则</strong></p>
<p>一般来说，需要自定义析构函数的类也需要自定义拷贝构造函数和拷贝赋值运算符。</p>
<p>因为一般来说需要自定义析构函数的类都含有动态分配的内存，需要手动定义析构函数来释放内存。这就是为什么需要同时定义拷贝构造函数和拷贝赋值运算符的原因，不然默认的拷贝构造和拷贝赋值只是简单地拷贝动态内存的地址，而不是创建新的内存来复制内容。</p>
<p><font color=blue>没有自定义的拷贝构造和拷贝赋值运算符会导致一块内存被多次释放。</font></p>
<p>同时，需要拷贝构造的类几乎可以肯定也需要拷贝赋值操作，反之亦然！</p>
<p>关于使用default的问题：</p>
<blockquote>
<p>与构造函数一样，可以显式将拷贝控制成员定义成=default来生成默认的版本。</p>
<p>如果=default在类内，则该成员函数就是内联的，在=default在类外成员函数就不是内联的。</p>
</blockquote>
<p><strong>阻止拷贝</strong></p>
<p>如果不想类的成员被拷贝构造或者拷贝赋值，那么可以将拷贝构造函数或拷贝赋值运算符定义成delete的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoCopy</span>&#123;</span></span><br><span class="line">  NoCopy() = <span class="keyword">default</span>;</span><br><span class="line">  NoCopy(<span class="keyword">const</span> NoCopy&amp; ) = <span class="keyword">delete</span>;  <span class="comment">//阻止了拷贝操作，也就是不能使用该类的一个对象来直接初始化另一个对象</span></span><br><span class="line">  NoCopy &amp;<span class="keyword">operator</span> = (<span class="keyword">const</span> NoCopy&amp; ) = <span class="keyword">delete</span>;  <span class="comment">//阻止了对该类的=操作</span></span><br><span class="line">  ~NoCpoy() = <span class="keyword">default</span>;  <span class="comment">//使用合成的析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>与=default不同，=delete必须出现在函数第一次出现的地方。</p>
<p>需要注意的是，<font color=red>析构函数在语法上可以被定义为删除函数，但是这样就会导致该类的对象无法被销毁，所以编译器就不允许定义该类型的变量或者创建该类的临时对象。</font></p>
<p>但是可以动态分配这种类型的对象，但是又不能释放这些对象。。。(?????????)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDtor</span>&#123;</span></span><br><span class="line">  NoDtor() = <span class="keyword">default</span>;</span><br><span class="line">  ~NoDtor() = <span class="keyword">delete</span>;  <span class="comment">//不能销毁该类型对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NoDtor nd;  <span class="comment">// 错误，不能声明该对象</span></span><br><span class="line">NoDtor *p = <span class="keyword">new</span> NoDtor();  <span class="comment">//正确，动态分配NoDtor内存。。</span></span><br><span class="line"><span class="keyword">delete</span> p;   <span class="comment">// 错误， 不能释放这些对象。(那不是就肯定存在内存泄露了？？？) </span></span><br></pre></td></tr></table></figure>
<p><strong>合成的拷贝控制成员可能是删除的情况</strong></p>
<p>如果一个类有数据成员不能默认构造、拷贝、赋值或者销毁，对应的成员函数将被定义为删除的。（具体看书）</p>
<p><strong>private拷贝控制</strong></p>
<p>在新标准之前，可以通过将拷贝控制成员声明为private的来禁止拷贝赋值，但最好使用新版本的操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateCopy</span>&#123;</span></span><br><span class="line">  <span class="comment">//class 默认的权限是private的，与struct相反</span></span><br><span class="line">  PrivateCopy(<span class="keyword">const</span> PrivateCopy&amp; );  <span class="comment">//这里的拷贝构造函数和赋值运算符都是私有的，所以无法进行拷贝构造和赋值</span></span><br><span class="line">  PrivateCopy&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> PrivateCopy&amp; );</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  PrivateCopy() = <span class="keyword">default</span>;</span><br><span class="line">  ~PrivateCopy() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>试图拷贝该类的对象的用户代码在<font color=blue>编译阶段</font>会被标记错误，类的成员函数和友元函数进行拷贝操作会在<font color=blue>链接</font>时错误。</p>
<h3 id="拷贝控制和资源管理"><a href="#拷贝控制和资源管理" class="headerlink" title="拷贝控制和资源管理"></a>拷贝控制和资源管理</h3><p>一般来说，如果一个类需要手动定义析构函数，那么它基本上可以肯定也需要手动定义一个拷贝构造函数和拷贝赋值运算符，因为需要释放动态分配的内存。</p>
<p>行为像值的类：副本和原对象完全独立，改变其中一个不会影响另一个。</p>
<p>行为像指针的类：副本和原对象使用相同的底层数据，改变其中一个会影响另外一个。</p>
<p><strong>行为像值的类</strong></p>
<p>拷贝类中指针指向的对象，而不是拷贝指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s = <span class="built_in">std</span>::<span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数，拷贝p.ps指针指向的对象到this.ps中</span></span><br><span class="line">  HasPtr(<span class="keyword">const</span> HasPtr&amp; p) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(*p.ps)), i(p.i) &#123;&#125;</span><br><span class="line">  <span class="comment">//拷贝赋值运算符</span></span><br><span class="line">  HasPtr&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> HasPtr&amp; );</span><br><span class="line">  ~HasPtr()&#123; <span class="keyword">delete</span> ps;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>赋值运算符=通常组合了析构函数和拷贝构造函数的作用。自定义赋值运算符要满足：</p>
<ul>
<li>能够实现对象自身给自身赋值<br>拷贝赋值的步骤：</li>
</ul>
<ol>
<li>先拷贝右侧的运算对象。</li>
<li>释放左侧运算对象的资源。</li>
<li>更新指针等，令其指向拷贝得到的对象。</li>
</ol>
<p>所以上面的operator=的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HasPtr&amp; HasPtr:: <span class="keyword">operator</span> = (<span class="keyword">const</span> HasPtr&amp; rhs)&#123;</span><br><span class="line">  <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps); <span class="comment">//先拷贝右侧运算对象，顺序不能错</span></span><br><span class="line">  <span class="keyword">delete</span> ps;  <span class="comment">//释放旧的内存</span></span><br><span class="line">  ps = newp;  <span class="comment">// 指向新内存</span></span><br><span class="line">  i = rhs.i;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>行为像指针的类</strong></p>
<p>可以用shared_ptr实现，也可以自定义引用计数来实现。<br>引用计数实现的一个方法是将计数器保存在一个动态内存中。（不能使用static变量）</p>
<p>创建一个新的对象时，分配一个新的计数器，当拷贝或者赋值时，拷贝指向计数器的指针。这样副本和原对象都会指向相同的计数器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>()) : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">  <span class="comment">//拷贝构造函数拷贝3个成员，并递增计数器</span></span><br><span class="line">  HasPtr(<span class="keyword">const</span> HasPtr&amp; p) : ps(p.ps), i(p.i), use(p.use) &#123; ++*p; &#125; <span class="comment">//这样子一来ps指向了p.ps所指向的内存，计数器+1</span></span><br><span class="line">  HasPtr <span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; );</span><br><span class="line">  ~HasPtr()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::~HasPtr()&#123;</span><br><span class="line">  <span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;  <span class="comment">//如果引用计数变为0，释放ps和use指向的内存</span></span><br><span class="line">    <span class="keyword">delete</span> use;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">HasPtr&amp; HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr&amp; rhs)&#123;</span><br><span class="line">  ++*rhs.use;  <span class="comment">//递增右侧运算对象的引用计数</span></span><br><span class="line">  <span class="keyword">if</span>(--*use == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    <span class="keyword">delete</span> use;</span><br><span class="line">  &#125;</span><br><span class="line">  ps = rhs.ps;</span><br><span class="line">  use = rhs.use;</span><br><span class="line">  i = rhs.i;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//返回本对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="交换操作swap"><a href="#交换操作swap" class="headerlink" title="交换操作swap"></a>交换操作swap</h3><p>管理资源的类通常还自己定义一个swap函数（非必须，而且标准库还默认定义了一个swap）。<br>高效的swap操作应该是交换指向对象的指针，而不是交换对象的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//其他成员与上面以一样</span></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp; lhs, HasPtr&amp; rhs)</span></span>&#123;  <span class="comment">//优化声明为内联函数</span></span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">  swap(lhs.ps, rhs.ps);</span><br><span class="line">  swap(lhs.i, rhs.i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象移动"><a href="#对象移动" class="headerlink" title="对象移动"></a>对象移动</h3><p>如果拷贝一个对象后，这个对象就被销毁了(如return)，在这种情况下，将对象进行移动就会大幅提升性能。<br>还有，如IO类和unique_ptr等不能进行拷贝，但是可以进行移动。</p>
<p><strong>右值引用</strong></p>
<p>必须绑定到右值的引用，通过&amp;&amp;获得右值引用。<br>性质:只能绑定到一个将要销毁的对象。<br>左值引用不能将其绑定到要求转换的表达式、字面常量或者返回右值的表达式。<br>右值引用与左值引用刚好相反。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;              <span class="comment">//正确，将r绑定到i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;            <span class="comment">//错误，不能将右值引用绑定到左值上。</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>;        <span class="comment">//错误，i*42是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>;  <span class="comment">//正确，可以将const引用绑定到右值上。</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;      <span class="comment">//正确，将右值引用绑定到乘法结果上。</span></span><br></pre></td></tr></table></figure>
<p>返回左值的表达式：</p>
<ol>
<li>返回左值引用的函数</li>
<li>赋值运算符</li>
<li>下标运算符</li>
<li>解引用运算符</li>
<li>前置递增递减运算符</li>
</ol>
<p>返回右值的表达式：</p>
<ol>
<li>返回非引用类型的函数</li>
<li>算术运算符</li>
<li>关系运算符</li>
<li>位运算符</li>
<li>后置递增递减运算符</li>
</ol>
<p>不可以将左值引用绑定到这类表达式中，<font color=red>但是可以将右值引用和const的左值引用绑定到这类表达式上。</font></p>
<p><strong><em>左值持久，右值短暂</em></strong></p>
<p>由于右值引用只能绑定到临时对象，所以该对象应该是：</p>
<blockquote>
<p>将要被销毁。</p>
<p>没有其他的地方使用到该对象。</p>
</blockquote>
<p>变量是左值，不能将右值引用绑定到一个变量上，即使这个变量本身是右值引用也不行，因为这个右值引用它本身首先是一个变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;   <span class="comment">//右值引用绑定到字面值常量</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;RR2 = rr1;  <span class="comment">//错误，不能将右值引用绑定到一个变量上。</span></span><br></pre></td></tr></table></figure>

<p><strong>std::move()</strong></p>
<p>我们可以通过使用定义在utility的std::move来获得一个绑定到左值的右值引用，也就是说可以通过这个函数将右值引用绑定到一个左值上，比如将绑定到一个变量上。就是告诉编译器，我们有一个左值，但我们想像一个右值一样来处理它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = <span class="built_in">std</span>::move(rr1);  <span class="comment">//将右值引用绑定到了一个变量上。</span></span><br></pre></td></tr></table></figure>
<p>除了对移动后的原对象(如，rr1)进行销毁和赋值外，我们不能再使用它。</p>
<h3 id="移动构造函数和移动赋值运算符"><a href="#移动构造函数和移动赋值运算符" class="headerlink" title="移动构造函数和移动赋值运算符"></a>移动构造函数和移动赋值运算符</h3><p><strong>移动构造函数</strong></p>
<p>原则：经过移动构造函数移动后，销毁一个源对象是无害的。我的理解就是移动后，源对象和之前它所指向的内存没有任何关系了，销毁源对象不会影响移动后的那个内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该移动构造函数接管s中的内存</span></span><br><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span>  <span class="comment">//移动操作不应抛出任何异常，注意s是一个右值引用</span></span><br><span class="line">: element(s.element), first_free(s.first_free), cap(s.cap)&#123;</span><br><span class="line">  s.element = s.first_free = s.cap = <span class="literal">nullptr</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，移动构造函数这是“窃取”别的对象的资源，不分配任何新的资源，所以一般不会抛出任何异常。所以应该使用noexcept通知标准库这段程序不会抛出异常，否则编译器可能会做一些额外的工作。。</p>
<p>为什么移动构造函数建议使用noexcept？<br>比如vector中，如果元素的移动构造函数不是显式声明不会抛出异常，那么在分配内存的时候，vector会使用拷贝构造函数而非移动构造函数来对对象进行拷贝而非移动，这样效率就会下降。所以建议移动构造函数标记为noexcept。</p>
<p><strong>移动赋值运算符</strong></p>
<p>与移动构造函数执行相同的操作，并且能够处理自赋值的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span> = (StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> != rhs)&#123;   <span class="comment">//如果不是自赋值，那么就执行常规赋值操作</span></span><br><span class="line">    <span class="built_in">free</span>();  <span class="comment">//释放本对象的原来的资源，free函数是之前自定义的函数</span></span><br><span class="line">    elements = rhs.elelments;</span><br><span class="line">    first_free = rhs.first_free;</span><br><span class="line">    cap = rhs.cap;</span><br><span class="line">    <span class="comment">//将rhs置于可析构状态，也就是删除它不会影响到this对象内存</span></span><br><span class="line">    rhs.element = rhs.first_free = rhs.cap;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回赋值后的本对象，如果是自赋值则直接返回自身即可。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于合成的移动操作：<br>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会再合成移动构造函数和移动赋值运算符。<font color=red>只有一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都能移动时，才会合成移动构造函数和移动赋值运算符。</font>可以移动的数据成员指的是内置类型和定义了对应移动操作的类类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span> i;   <span class="comment">//内置类型可以移动</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s;  <span class="comment">//string定义了自己的移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hasX</span>&#123;</span></span><br><span class="line">  X mem;    <span class="comment">//X有合成的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x;</span><br><span class="line">X x2 = <span class="built_in">std</span>::move(x);  <span class="comment">//使用X合成的移动构造函数</span></span><br><span class="line"></span><br><span class="line">hasX hx;</span><br><span class="line">hasX hx2 = <span class="built_in">std</span>::move(hx);   <span class="comment">//使用hasX合成的移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>与拷贝操作不同，移动操作永远不会<font color=red>隐式地</font>定义为删除的函数。</p>
<p>移动构造函数会被定义为删除的函数的情况：</p>
<ul>
<li>与拷贝构造函数不同，如果有类成员定义了自己的拷贝构造函数且为定义移动构造函数，或者类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数，则该类的移动构造函数是删除的。</li>
<li>类成员的移动构造函数或者移动赋值运算符被定义为删除的或者不可访问的，则该类的移动构造函数和移动赋值运算符被定义为删除的。</li>
<li>类似拷贝构造函数，如果类的析构函数被定义为删除的或者不可访问的，则该类的移动构造函数被定义为删除的。</li>
<li>类似拷贝赋值运算符，如果类有const或者引用成员，则类的移动赋值运算符被定义为删除的。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasY</span>&#123;</span></span><br><span class="line">  hasY() = defauult;</span><br><span class="line">  hasY(hasY&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Y mem;   <span class="comment">///Y 是一个定义了自己的拷贝构造函数但未定义自己得移动构造函数的类</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">hasY hy;</span><br><span class="line">hasY hy2 = <span class="built_in">std</span>::move(hy);  <span class="comment">//错误，hasY的移动构造函数是删除的</span></span><br></pre></td></tr></table></figure>
<p><font color=red>如果一个类定义了移动构造函数或者移动赋值运算符，那么该类合成的拷贝构造函数和拷贝赋值运算符会被定义为删除的。</font></p>
<p>如果没有移动构造函数，那么右值也会进行拷贝。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  Foo() = defualt;  <span class="comment">//</span></span><br><span class="line">  Foo(<span class="keyword">const</span> Foo&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">Foo x;</span><br><span class="line">Foo y;</span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(<span class="built_in">std</span>::move(x))</span></span>;  <span class="comment">//这里使用的是拷贝构造函数，因为未定义移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>用拷贝构造函数来代替移动构造函数几乎肯定是安全的。其实我觉得移动构造函数就是适用于右值版本的拷贝构造函数。</p>
<p><strong>移动迭代器</strong></p>
<p>一般的迭代器的解引用运算符返回一个指向给定元素的左值，而移动迭代器的解引用运算符返回一个右值引用。</p>
<p>可以使用make_move_iterator来将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都能正常工作。</p>
<p>在类外不要随意使用移动操作，只有移动后源对象不在使用的情况下才能使用移动操作。</p>
<p><strong>右值引用和成员函数</strong></p>
<p>成员函数也可以有拷贝形式和移动形式。例如定义了push_back的标准库容器提供两个版本：右值引用版本和const左值引用版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>;    <span class="comment">//拷贝，绑定到任意的X类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;    <span class="comment">//移动，绑定到X的可修改右值</span></span><br></pre></td></tr></table></figure>
<p>一般来说拷贝函数参数应该是const T&amp;，而移动函数形参应该是T&amp;&amp;。<br>定义拷贝和移动形式的成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;   <span class="comment">//拷贝形式</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp;)</span></span>;     <span class="comment">//移动形式</span></span><br><span class="line">  <span class="comment">//其他成员。。。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span></span>&#123;</span><br><span class="line">  chk_n_alloc();   <span class="comment">//检查空间是否足够，不够扩容</span></span><br><span class="line">  <span class="comment">//在first_free的指向的元素中构造s的一个副本</span></span><br><span class="line">  alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; s)</span></span>&#123;</span><br><span class="line">  chk_n_alloc();</span><br><span class="line">  alloc.construct(first_free, <span class="built_in">std</span>::move(s));  <span class="comment">//使用string的移动构造函数来构造新元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec vec;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;some string or another.&quot;</span>;</span><br><span class="line">vec.push_back(s); <span class="comment">//调用的是push_back(const std::string&amp;s)</span></span><br><span class="line">vec.push_back(<span class="string">&quot;done&quot;</span>);  <span class="comment">//调用的是push_back(string&amp;&amp;)</span></span><br></pre></td></tr></table></figure>

<p><strong><em>左值、右值引用成员函数</em></strong></p>
<p>注意，新标准库仍然允许向右值赋值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;s1&quot;</span>, s2 = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> n = (s1 + s2).find(<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">s1 + s2 = <span class="string">&quot;hhhhhh&quot;</span>;   <span class="comment">//很奇怪的方式</span></span><br></pre></td></tr></table></figure>
<p>如果要强制左侧运算对象是一个左值，可以在this的参数列表后放置一个引用限定符&amp;。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  Foo&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> Foo&amp;) &amp;;  <span class="comment">//只能向可修改的左值赋值</span></span><br><span class="line">  <span class="function">Foo <span class="title">mem</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;   <span class="comment">//引用限定符须在const之后</span></span><br><span class="line">&#125;;</span><br><span class="line">Foo&amp; Foo::<span class="keyword">operator</span> = (<span class="keyword">const</span> Foo &amp;rhs)&#123;</span><br><span class="line">  <span class="comment">//将rhs赋值给this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中引用限定符可以是&amp;和&amp;&amp;，与const类似，引用限定符只能用于非static成员函数。<br>还有，如果一个成员函数有引用限定符，那么具有相同参数列表的所有版本都必须加上引用限定符。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-关联容器" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>关联容器支持普通容器的操作，不支持顺序容器中<strong>位置相关</strong>的操作，如push_back等，也不支持构造函数或插入操作的接收一个元素值和数量值得操作，如vector&lt; int&gt;v(10,0)。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">普通容器的操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>类型别名</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">iterator</td>
<td align="center">此容器类型的迭代器</td>
</tr>
<tr>
<td align="center">const_iterator</td>
<td align="center">可以读取元素，但不能修改元素的迭代器类型</td>
</tr>
<tr>
<td align="center">size_type</td>
<td align="center">无符号整数类型，足够保存此种容器类型最大可能容器的大小</td>
</tr>
<tr>
<td align="center">diference_type</td>
<td align="center">带符号整数类型，足够保存两个迭代器之间的距离</td>
</tr>
<tr>
<td align="center">value_type</td>
<td align="center">元素类型</td>
</tr>
<tr>
<td align="center">refernce</td>
<td align="center">左值引用；与value_type&amp;含义相同</td>
</tr>
<tr>
<td align="center">const_refernce</td>
<td align="center">元素的const左值类型（const value_type&amp;）</td>
</tr>
<tr>
<td align="center"><strong>构造函数</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">C c;</td>
<td align="center">默认构造函数，构造空容器（array除外）</td>
</tr>
<tr>
<td align="center">C c1(c2)</td>
<td align="center">用c2来拷贝构造c1</td>
</tr>
<tr>
<td align="center">C c3(b, e)</td>
<td align="center">用迭代器b,e范围内的元素拷贝构造c3(array不支持)</td>
</tr>
<tr>
<td align="center">C c{a,b,d,…}</td>
<td align="center">列表初始化c</td>
</tr>
<tr>
<td align="center"><strong>赋值与交换</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">c1 = c2</td>
<td align="center">将c1中的值替换成c2的值</td>
</tr>
<tr>
<td align="center">c1 = {a,b,d,…}</td>
<td align="center">将c1中的值替换成列表元素</td>
</tr>
<tr>
<td align="center">a.swap(b)</td>
<td align="center">交换a和b的元素</td>
</tr>
<tr>
<td align="center">swap(a,b)</td>
<td align="center">与上等价</td>
</tr>
<tr>
<td align="center">大小</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">c.size()</td>
<td align="center">c中元素的数目（forward_list不支持）</td>
</tr>
<tr>
<td align="center">c.max_size()</td>
<td align="center">c中可保存的最大元素数目</td>
</tr>
<tr>
<td align="center">c.empty()</td>
<td align="center">若c中存储了元素，则返回false，否则返回true</td>
</tr>
<tr>
<td align="center"><strong>添加删除元素</strong>(array不支持,不同容器接口不尽相同)</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">c.insert(args)</td>
<td align="center">将args插入c</td>
</tr>
<tr>
<td align="center">c.emplace(inits)</td>
<td align="center">使用inits构造c中的一个元素</td>
</tr>
<tr>
<td align="center">c.erase(args)</td>
<td align="center">删除args指定的元素</td>
</tr>
<tr>
<td align="center">c.clear()</td>
<td align="center">删除c中所有元素，返回void</td>
</tr>
<tr>
<td align="center"><strong>关系运算符</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">==, !=</td>
<td align="center">所有容器都支持相等(不等)运算符</td>
</tr>
<tr>
<td align="center">&lt;,&lt;=,&gt;,&gt;=</td>
<td align="center">关系运算符(无序关联容器不支持)</td>
</tr>
<tr>
<td align="center"><strong>获取迭代器</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">c.begin(),c.end()</td>
<td align="center">返回指向c中首元素和尾元素之后位置的迭代器</td>
</tr>
<tr>
<td align="center">c.cbegin(),c.cend()</td>
<td align="center">返回常迭代器</td>
</tr>
<tr>
<td align="center"><strong>反向容器的额外成员</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">reverse_iterator</td>
<td align="center">逆序寻址元素的迭代器</td>
</tr>
<tr>
<td align="center">const_reverse_iterator</td>
<td align="center">不修改元素的逆序迭代器</td>
</tr>
<tr>
<td align="center">c.rbegin(),c.rend()</td>
<td align="center">返回指向c的尾元素和首元素之前位置的迭代器</td>
</tr>
<tr>
<td align="center">c.crbegin(),c.crend()</td>
<td align="center">返回const_reverse_iterator</td>
</tr>
</tbody></table>
<p>关联容器的迭代器都是双向的。</p>
<table>
<thead>
<tr>
<th><strong>关联容器额外的类型别名</strong></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>key_type</td>
<td align="center">此容器类型的关键字类型</td>
</tr>
<tr>
<td>mapped_type</td>
<td align="center">每个关键字关联的类型，只适用于map</td>
</tr>
<tr>
<td>value_type</td>
<td align="center">对于set，与key_value相同，对于map,为pair&lt;const key_type, mapped_type&gt;</td>
</tr>
</tbody></table>
<p>关联容器通常不使用泛型算法，也就是STL中的算法。因为set中元素是const的，map中pair.first也是const的，会修改容器元素的算法都不能使用。可以用于<font color=red>只读取元素</font>的算法，但是会比较慢，不如关联容器内置的算法。</p>
<h2 id="有序容器"><a href="#有序容器" class="headerlink" title="有序容器"></a>有序容器</h2><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a><strong>pair</strong></h3><p>存放在头文件utility中。</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">pair操作</th>
</tr>
</thead>
<tbody><tr>
<td>pair&lt;T1, T2&gt;p;</td>
<td align="center">定义类型为T1、T2类型的pair，并进行值初始化。</td>
</tr>
<tr>
<td>pair&lt;T1, T2&gt;p(v1,v2);</td>
<td align="center">如上，其first和second成员被初始化为v1,v2。</td>
</tr>
<tr>
<td>pair&lt;T1,T2&gt;p = {v1,v2};</td>
<td align="center">等价于上面。</td>
</tr>
<tr>
<td>make_pair(v1,v2);</td>
<td align="center">返回v1,v2初始化的pair,其类型从v1,v2类型推断出来。</td>
</tr>
<tr>
<td>p.first</td>
<td align="center">返回p的名为first的共有数据成员。</td>
</tr>
<tr>
<td>p.second</td>
<td align="center">返回p的名为second的共有数据成员。</td>
</tr>
<tr>
<td>p1 relop p2</td>
<td align="center">关系运算符(&lt;,&lt;=,&gt;,&gt;=)按字典序定义：当p1.first&lt;p2.first &amp;&amp; p1.second &lt; p2.second成立时，p1 &lt; p2返回true。</td>
</tr>
<tr>
<td>p1 == p2</td>
<td align="center">first和second两个成员分别相等时成立。</td>
</tr>
</tbody></table>
<p><font color=red>map(multimap)</font>的value_type是一个pair，其first成员保存const的关键字，second成员保存值。</p>
<p>遍历map</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;word_count = &#123;&#123;<span class="string">&quot;Tim&quot;</span>, <span class="number">20</span>&#125;, &#123;<span class="string">&quot;Jack&quot;</span>, <span class="number">15</span>&#125;, &#123;<span class="string">&quot;Rose&quot;</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">auto</span> map_iter = word_count.cbegin();</span><br><span class="line"><span class="keyword">while</span>(map_iter != word_count.cend())&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; map_iter-&gt;first &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; map_iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++map_iter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map、multimap、set、multiset的迭代器按照关键字升序遍历元素。</p>
<p>添加元素：</p>
<table>
<thead>
<tr>
<th>map</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>map.insert(v);</td>
<td>v是value_type对象</td>
</tr>
<tr>
<td>map.emplace(args);</td>
<td>返回pair，其first是一个迭代器，指向具有指定关键字的元素，second是指示插入是否成功的bool值，对于multimap和multiset总会插入给定元素，并返回指向新元素的迭代器。</td>
</tr>
<tr>
<td>map.insert(b, e);</td>
<td>b,e是迭代器，表示一个c::value_type类型的范围。</td>
</tr>
<tr>
<td>map.insert({…})</td>
<td>插入花括号的值列表，返回<strong>void</strong>。对于set和map,只会插入不在容器中的关键字，对于multiset和multimap则每个元素都会插入。</td>
</tr>
<tr>
<td>map.insert(p,v)</td>
<td>p是迭代器，表示从p开始搜索新元素应该存储的位置，返回一个指向具有给定关键字的迭代器。</td>
</tr>
<tr>
<td>map.emplace(p,v)</td>
<td>同上版本</td>
</tr>
</tbody></table>
<p>对于插入的返回值，可以写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt; ret = word_count.insert(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line"><span class="comment">//插入的返回值是一个pair,其first是word_count同类型的迭代器，，second是表示插入是否成功的bool值。</span></span><br></pre></td></tr></table></figure>

<p>set的迭代器是const的，也就是说迭代器只能访问set成员，而不能修改。</p>
<p>向multimap、multiset中插入元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">multimap</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;authors;</span><br><span class="line"><span class="comment">//插入 第一个元素，关键字为Tom</span></span><br><span class="line">authors.insert(&#123;<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Book1&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//插入第二个元素，关键字还是Tom</span></span><br><span class="line">authors.insert(&#123;<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;Book2&quot;</span>&#125;);<span class="comment">//正确，multi关联容器关键字不唯一。</span></span><br></pre></td></tr></table></figure>

<p>删除元素</p>
<p>关联容器定义了3个版本的erase：</p>
<table>
<thead>
<tr>
<th></th>
<th>关联容器删除元素</th>
</tr>
</thead>
<tbody><tr>
<td>c.erase(k)</td>
<td>删除c中每个关键字为k的元素。返回size_type值，表示删除元素的数量。</td>
</tr>
<tr>
<td>c.erase(p)</td>
<td>从c中删除迭代器p指向的c中的元素，且不能是c.end()。返回指向p之后元素的迭代器。</td>
</tr>
<tr>
<td>c.erase(b, e)</td>
<td>删除迭代器b和e所表示范围内的元素，返回迭代器e。</td>
</tr>
</tbody></table>
<p>map的下标操作(查找元素时推荐用find函数)：</p>
<p>map和unordered_map支持下表运算符和对应的at()函数。set类、multi类不支持。</p>
<table>
<thead>
<tr>
<th></th>
<th>map\unordered_map的下标操作和at()函数</th>
</tr>
</thead>
<tbody><tr>
<td>c[k]</td>
<td>返回关键字为k的元素，若c中不存在k，则添加一个关键字为k的元素并进行值初始化。</td>
</tr>
<tr>
<td>c.at(k)</td>
<td>访问关键字为k的元素，带参数检查，若k不在c中，抛出out_of_range异常</td>
</tr>
<tr>
<td>下标操作要注意的是，<strong>如果下标关键字不在map中，会为该容器自动创建一个该关键字的元素，且其映射值会进行值初始化！</strong></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;word_count; <span class="comment">//这是空的map</span></span><br><span class="line">word_count[<span class="string">&quot;Tom&quot;</span>] = <span class="number">1</span>; <span class="comment">//map中没有关键字为Tom的元素，自动创建该元素。。</span></span><br></pre></td></tr></table></figure>
<p>并且由于下标操作会改变容器，所以只能对非const的map和unordered_map进行下标操作！</p>
<p>map下标运算符返回值与其他下标运算符返回值另一个不同之处：同常情况下，解引用一个迭代器返回的类型和下标运算返回的类型是一样的，<font color=red>但是对map进行下标操作是，返回的是mapped_type对象，解引用map的迭代器时会得到value_type对象。</font><br>map的下标运算符与其他下标运算符一样，返回一个左值，我们可以对下标操作的元素进行读和写。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt; word_count[<span class="string">&quot;Tom&quot;</span>]; <span class="comment">//提取关键字为Tom的元素，打印结果是1.</span></span><br><span class="line">++ word_count[<span class="string">&quot;Tom&quot;</span>]; <span class="comment">//修改元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; word_count[<span class="string">&quot;Tom&quot;</span>] <span class="comment">//会输出2</span></span><br></pre></td></tr></table></figure>

<p>访问元素</p>
<table>
<thead>
<tr>
<th></th>
<th>访问关联容器中元素的操作</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>下标操作和at()只适用于非const的map和unordered_map。</td>
</tr>
<tr>
<td>c.find(k)</td>
<td>返回指向第一个关键字为k的迭代器，若k不在容器中，则返回尾后迭代器。</td>
</tr>
<tr>
<td>c.count(k)</td>
<td>返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值只能是0或1.</td>
</tr>
<tr>
<td>c.lower_bound(k)</td>
<td>返回指向第一个关键字不小于k的元素的迭代器。</td>
</tr>
<tr>
<td>c.upper_bound(k)</td>
<td>返回指向第一个关键字大于k的元素的迭代器。</td>
</tr>
<tr>
<td>c.equal_range(k)</td>
<td>返回一个迭代器pair,表示关键字等于k的元素的范围，若k不在c中，则pair的两个成员均为c.end()。</td>
</tr>
</tbody></table>
<p><strong>如果只需要确定元素是否在一个容器中，使用find(k)而不是[k]!</strong></p>
<p><font color=red>对于multimap和multiset，如果具有多个相同的关键字，则这些元素会相邻存储。</font></p>
<p>对于c.lower_bound()和c.upper_bound(),两者组合可得到关键字等于k的元素的范围。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> begin = word_count.lower_bound(k), end = word_count.upper_bound(k); begin != end; ++begin)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; begin.second &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出关键字等于k的元素的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果lower_bound和upper_bound返回相同迭代器，说明该关键字不在容器中。</p>
<p>equal_range(k)<br>直接返回关键字等于k的元素的范围，等价于lower_bound和upper_bound。其返回值是一个迭代器pair。第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配的元素的<strong>后一个位置</strong>。</p>
<h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>unordered_map、unordered_set、unordered_multimap、unordered_multiset。<br>无序关联容器不是使用比较运算符(&lt;,&lt;=,&gt;,&gt;=,默认使用&lt;来进行比较)来组织元素的，而是使用哈希函数和关键字类型的==运算符。<br>无序容器在存储上组织为一个桶，使用哈希函数将元素映射到相应桶。对哈希函数的要求是，相同的参数，哈希函数必须总是产生相同都得结果，但是不同参数产生相同的结果也是允许的。</p>
<p>与有序容器不同，不能直接定义关键字类型为自定义类型的无序容器,如果确实需要定义这样类型的容器，需要提供该自定义类型的hash模板。</p>
<table>
<thead>
<tr>
<th></th>
<th>无序容器管理操作</th>
</tr>
</thead>
<tbody><tr>
<td>桶接口</td>
<td></td>
</tr>
<tr>
<td>c.bucket_count()</td>
<td>正在使用的桶的数目。</td>
</tr>
<tr>
<td>c.max_bucket_count()</td>
<td>容器能容纳最多的桶的数量。</td>
</tr>
<tr>
<td>c.bucket_size(n)</td>
<td>第n个桶有多少个元素。</td>
</tr>
<tr>
<td>c.bucket(k)</td>
<td>关键字为k的元素在哪个桶中。</td>
</tr>
<tr>
<td>桶迭代</td>
<td></td>
</tr>
<tr>
<td>local_iterator</td>
<td>可以用来访问桶中元素的迭代器类型。</td>
</tr>
<tr>
<td>const_local_iterator</td>
<td>桶迭代器的const版本。</td>
</tr>
<tr>
<td>c.begin(n),c.end(n)</td>
<td>桶n的首元素迭代器和尾后迭代器。</td>
</tr>
<tr>
<td>c.cbegin(n),c.cend(n)</td>
<td>上面的const版本。</td>
</tr>
<tr>
<td>哈希策略</td>
<td></td>
</tr>
<tr>
<td>c.load_factor()</td>
<td>每个桶的平均元素数量，float型。</td>
</tr>
<tr>
<td>c.max_load_factor()</td>
<td>c试图维护的平均桶大小，返回float值。c会在需要时添加新的桶，使得load_factor&lt;=max_load_factor。</td>
</tr>
<tr>
<td>c.rehsah(n)</td>
<td>重组存储，使得bucket_count &gt;= n且bucket_count&gt;=n。</td>
</tr>
<tr>
<td>c.reserve(n)</td>
<td>重组存储，使得c可以保存n个元素且不必rehash。</td>
</tr>
</tbody></table>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-顺序容器" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="顺序容器类型"><a href="#顺序容器类型" class="headerlink" title="顺序容器类型"></a>顺序容器类型</h3><table>
<thead>
<tr>
<th></th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td>vector</td>
<td align="center">可变大小数组，支持快速随机访问，尾部之外位置插入删除元素会很慢。</td>
</tr>
<tr>
<td>deque</td>
<td align="center">双端队列，支持快速随机访问，在头尾插入删除速度都很快(list和forward_list相当)。</td>
</tr>
<tr>
<td>list</td>
<td align="center">双向链表，只支持双向顺序访问不支持随机访问，在任何位置插入删除速度都很快。</td>
</tr>
<tr>
<td>forward_list</td>
<td align="center">双向链表，只支持双向顺序访问不支持随机访问，在任何位置插入删除速度都很快。</td>
</tr>
<tr>
<td>array</td>
<td align="center">固定大小数组，支持快速随机访问，不能添加删除元素。</td>
</tr>
<tr>
<td>string</td>
<td align="center">与vector类似，专门用于保存字符。随机访问快，尾部插入删除快。</td>
</tr>
</tbody></table>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><table>
<thead>
<tr>
<th></th>
<th align="center">标准容器迭代器运算符</th>
</tr>
</thead>
<tbody><tr>
<td>*iter</td>
<td align="center">返回迭代器iter所指向元素的引用。</td>
</tr>
<tr>
<td>iter-&gt;men</td>
<td align="center">解引用iter并获取该元素的mem成员，等价于(*iter).mem。</td>
</tr>
<tr>
<td>++iter</td>
<td align="center">令iter指向容器中下一元素。</td>
</tr>
<tr>
<td>- -iter</td>
<td align="center">令iter指向容器中上一元素。</td>
</tr>
<tr>
<td>iter1 == iter2 iter1 != iter2</td>
<td align="center">判断两迭代器是否相等，若指向同一元素或同一容器尾后迭代器，则相等，否则不等。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;some string.&quot;</span>)</span></span>;</span><br><span class="line"><span class="comment">//将字符串转换成大写，遇到空格或结尾停止</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*it); ++it)&#123; <span class="comment">//begin(),end()为容器首元素迭代器和尾后迭代器，*it为解引用，也就是it指向的元素。</span></span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++中，只有string和vector等标准库类型有下标运算符，并非全部类型都有。所有的容器的迭代器都定义了==和!=运算符，除了无序关联容器外都定义了关系运算符(&gt;, &gt;=, &lt;, &lt;=)，所以最好养成迭代器和!=一起使用的习惯。</p>
<p><font color=red>容器</font>的相等运算实际是调用<font color=red>元素</font>的==运算符实现的。<br>而其他关系运算符是使用元素的&lt; 运算符。如果元素类型不支持该运算符，那就不能进行关系运算。</p>
<p>迭代器范围</p>
<p>迭代器的范围为左闭右开区间[begin,end),其中begin是容器首元素，end是最后一个元素的后一个位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27; &#x27;</span>)</span></span>;<span class="comment">//创建10个空格的string</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.begin(); it != s.end(); ++ it)&#123;</span><br><span class="line">    *it = <span class="string">&#x27;c&#x27;</span>; <span class="comment">//为迭代器指向的元素赋值</span></span><br><span class="line">   <span class="comment">// ++it; //指向下一元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器类型别名</p>
<p>通过类型别名，可以在不了解容器元素类型的情况下使用它。若需要确定元素类型，可以使用容器的value_type，如果需要元素类型的一个引用，可以使用reference或者const_reference。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt;::iterator iter; <span class="comment">//通过list&lt;string&gt;定义的一个迭代器类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::defference_type count; <span class="comment">//通过vector&lt;int&gt;定义的difference_type类型</span></span><br></pre></td></tr></table></figure>

<h2 id="顺序容器定义及初始化"><a href="#顺序容器定义及初始化" class="headerlink" title="顺序容器定义及初始化"></a>顺序容器定义及初始化</h2><p>每个容器类型都定义了一个默认构造函数。除array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接收指定容器大小和初值的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v; <span class="comment">//默认构造函数，v是空的vector</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="number">10</span>); <span class="comment">//定义大小为10int的空vector，除arraystring外都支持</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v(<span class="number">10</span>,<span class="number">1</span>); <span class="comment">//创建10个元素为1的vector，除array外其他顺序容器都支持这种创建方式</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; arr; <span class="comment">//10个默认初始化的int</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; arr1 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">//列表初始化</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; arr2 = arr1; <span class="comment">//拷贝赋值，类型大小必须都一样， 内置数组不支持这样操作</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>定义和初始化方式</th>
</tr>
</thead>
<tbody><tr>
<td>C c;</td>
<td>默认构造函数，构建一个空的顺序容器，除array外，array会按默认方式进行初始化。</td>
</tr>
<tr>
<td>C c1(c2);     C c1 = c2;</td>
<td>c1初始化为c2的拷贝，c1c2类型必须相同，对于array，大小还必须相同。</td>
</tr>
<tr>
<td>C c{a,b,c,…};  C c={a,b,c,…}</td>
<td>c初始化为列表中元素，元素类型必须相同，对于array，列表元素数目必须小于等于array大小</td>
</tr>
<tr>
<td>C c(b,e)</td>
<td>c初始化为迭代器be之间的元素，且元素类型必须相容(array不适用)</td>
</tr>
<tr>
<td>只有顺序容器(array除外)的构造函数才能接收大小参数</td>
<td></td>
</tr>
<tr>
<td>C s(n);</td>
<td>创建的c大小为n，进行了值初始化，且此构造函数时显式的。(string不适用)</td>
</tr>
<tr>
<td>C s(n, t)</td>
<td>创建n个初值为t的顺序容器。</td>
</tr>
</tbody></table>
<h3 id="赋值和swap"><a href="#赋值和swap" class="headerlink" title="赋值和swap"></a>赋值和swap</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c1 = c2; <span class="comment">//将容器c1的内容替换为c2中的拷贝</span></span><br><span class="line">c1 = &#123;a, b, c&#125;; <span class="comment">//赋值后，c的大小为3</span></span><br></pre></td></tr></table></figure>
<p>容器为array的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; a2 = &#123;<span class="number">0</span>&#125;; <span class="comment">//所有元素初始化为0</span></span><br><span class="line">a1 = a2; <span class="comment">//正确，array支持赋值</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;; <span class="comment">//错误，不能将花括号列表赋予数组。此外，array也不支持assign。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>容器赋值运算</th>
</tr>
</thead>
<tbody><tr>
<td>c1 = c2</td>
<td>将c2拷贝赋值给c1，必须具有相同类型</td>
</tr>
<tr>
<td>c = {a,b,…}</td>
<td>列表初始化，array不支持</td>
</tr>
<tr>
<td>c1.swap(c2); swap(c1, c2);</td>
<td>交换c1c2中的元素，必须具有相同类型。通常比拷贝快很多。</td>
</tr>
<tr>
<td>assign不支持关联容器和array</td>
<td></td>
</tr>
<tr>
<td>seq.assign(b, e);</td>
<td>将seq中的元素替换为迭代器b,e范围内的元素。b,e不能指向seq。会替换所有元素</td>
</tr>
<tr>
<td>seq.assign(il);</td>
<td>将seq中的元素替换为初始化列表中的元素</td>
</tr>
<tr>
<td>seq.assign(n, t);</td>
<td>将seq中的元素替换为n个值为t的元素。</td>
</tr>
<tr>
<td><font color=red>赋值运算会导致指向左边容器内部的迭代器、引用、指针失效，而swap则不会。（array和string除外。）</font></td>
<td></td>
</tr>
<tr>
<td>对于除array以外的容器，其大小不一样也可以swap，如：</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1 = &#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v2 = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;jack&quot;</span>&#125;;</span><br><span class="line">swap(v1, v2);</span><br></pre></td></tr></table></figure>
<p>除array外，swap只是交换两个容器内部的数据结构，并没有进行元素拷贝移动或者插入，所以速度很快。对于string，swap会导致其迭代器、引用、指针失效。</p>
<blockquote>
<p>小练习：编写程序，将一个list中的char*指针元素赋值给一个vector中的string</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">char</span>*&gt; c = &#123;<span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line">v.assign(c.cbegin(), c.cend());</span><br></pre></td></tr></table></figure>

<h3 id="容器大小操作"><a href="#容器大小操作" class="headerlink" title="容器大小操作"></a>容器大小操作</h3><p>forward_list支持max_size,empty。<br>其余容器都支持size,max_size,empty三种操作。</p>
<h3 id="顺序容器添加元素"><a href="#顺序容器添加元素" class="headerlink" title="顺序容器添加元素"></a>顺序容器添加元素</h3><p>forward_list有自己专属的insert和emplace<br>forward_list不支持push_back和emplace_back<br>vector和string不支持push_front和emplace_front<br><font color=red>向一个vector、string和deque插入元素会使指向其的迭代器、引用和指针失效。</font><br><font color=red>向一个vector、string和deque的任何位置插入元素都是合法的，但是会很慢。</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; l;</span><br><span class="line"><span class="comment">//等价于调用l.push_front(&quot;Hello!&quot;);</span></span><br><span class="line">l.insert(l.begin(), <span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"><span class="comment">//vector不支持push_front，但可以插入到begin之前，会很慢</span></span><br><span class="line">v.insert(v.begin(), <span class="string">&quot;Hello!&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将vector<string>中的字符串赋值给list<string>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;rose&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; l = &#123;<span class="string">&quot;downey&quot;</span>&#125;;</span><br><span class="line">l.insert(l.begin(), v.begin(), v.end()); <span class="comment">//在l开头插入</span></span><br><span class="line">l.insert(l.end(), v.begin(), v.end()); <span class="comment">//在l末尾插入</span></span><br><span class="line"><span class="comment">//对于insert，返回指向其插入的第一个元素的迭代器</span></span><br></pre></td></tr></table></figure>

<p><strong>emplace</strong><br>新标准引入emplace_front,emplace,emplace_back对应push_front,insert,push_back。<br>不同之处是，调用push或insert成员函数时，是将元素类型的对象传递给他们，这些对象被拷贝到容器中。而调用emplace成员函数时，是将参数传递给元素类型的构造函数，在内存空间中直接构造元素。</p>
<p>也就是说传递给emplace的参数必须与元素类型的构造函数参数像匹配。</p>
<h3 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h3><p>所有顺序容器都有front成员，除forward_list外都有back成员函数。</p>
<table>
<thead>
<tr>
<th></th>
<th>顺序容器访问元素</th>
</tr>
</thead>
<tbody><tr>
<td>c.back();</td>
<td>返回c中尾元素引用，若c为空，函数行为未定义。</td>
</tr>
<tr>
<td>c.front();</td>
<td>返回c中首元素引用，若c为空，函数行为未定义。</td>
</tr>
<tr>
<td>c.at(k);</td>
<td>返回下标为n的元素的引用，如越界，抛出out_of_range异常。</td>
</tr>
<tr>
<td>c[n];</td>
<td>返回下标n的元素的引用，若n&gt;=c.size()，函数行为未定义。</td>
</tr>
<tr>
<td>对于顺序容器,at和下标操作只适用于string,vector,deque,array。back不适用于forward_list。</td>
<td></td>
</tr>
<tr>
<td>容器中访问元素的成员函数(front,back，下标和at)都返回元素的<font color=red>引用</font>。如容器是<font color=red>const对象</font>，则返回的也是<font color=red>const引用</font>。</td>
<td></td>
</tr>
</tbody></table>
<p>提供快速随机访问的容器(string,vector,array,deque)都提供下标运算。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><table>
<thead>
<tr>
<th></th>
<th>顺序容器删除操作</th>
</tr>
</thead>
<tbody><tr>
<td>c.pop_back();</td>
<td>删除尾元素，返回void。若c为空，函数行为未定义。</td>
</tr>
<tr>
<td>c.pop_front();</td>
<td>删除首元素，返回void。若c为空，函数行为未定义。</td>
</tr>
<tr>
<td>c.erase(p);</td>
<td>删除迭代器所指向的元素，返回被删除元素之后一个元素的迭代器，若p是尾后迭代器，函数行为围挡一。</td>
</tr>
<tr>
<td>c.erase(b,e);</td>
<td>删除迭代器be范围内的元素。指向最后一个被删除元素的后一个元素的迭代器。若e本身就是尾后迭代器，则也返回尾后迭代器。</td>
</tr>
<tr>
<td>c.clear();</td>
<td>删除c中所有元素，返回void</td>
</tr>
<tr>
<td><font color=red>删除deque中首尾元素之外的任何元素都会使迭代器、引用、指针失效。指向vector、string中删除点之后的位置的迭代器、引用、指针也都会失效。</font></td>
<td></td>
</tr>
</tbody></table>
<p><strong>特殊的forward_list插入删除操作</strong></p>
<p>单向链表，无法获取一个元素的前驱节点，所以只能改变一个元素的后一个元素来实现插入删除。</p>
<table>
<thead>
<tr>
<th></th>
<th>forward_list中插入或删除元素</th>
</tr>
</thead>
<tbody><tr>
<td>lst.before_begin();lst.cbefore_begin()</td>
<td>返回指向链表首元素之前不存在的元素的迭代器，不能解引用。</td>
</tr>
<tr>
<td>lst.insert_after(p, t); lst.insert_after(p,n,t); lst.insert_after(p,b,e); lst.insert_after(p, il);</td>
<td>在迭代器p之后插入元素。t是一个元素，n是数量。be表示一对迭代器。il是花括号列表，返回一个指向最后一个插入元素的迭代器。若范围空，则返回p。若p尾后迭代器则函数行为未定义。</td>
</tr>
<tr>
<td>lst.emplace_after(p.args);</td>
<td>使用参数在p元素后创建一个新元素。返回指向这个新元素的迭代器。若p为尾后迭代器，函数行为未定义。</td>
</tr>
<tr>
<td>lst.erase_after(p); lst.erase_after(b,e);</td>
<td>删除p指向元素之后的元素。或者删除b到e前1个元素范围内的元素。若不存在这样的元素，返回尾后迭代器。若p指向lst的尾元素或尾后迭代器，则函数行为未定义。</td>
</tr>
</tbody></table>
<h3 id="改变容器大小"><a href="#改变容器大小" class="headerlink" title="改变容器大小"></a>改变容器大小</h3><p>resize扩大或缩小容器。若当前大小&gt;要求的大小，则容器后面的元素会被删除，如果当前大小&lt;要求大小，会将新元素添加到容器后面。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>; <span class="comment">//10个int，每个都是42</span></span><br><span class="line">ilist.resize(<span class="number">15</span>); <span class="comment">//5个值为0的元素添加到容器尾部。</span></span><br><span class="line">ilist.resize(<span class="number">25</span>, <span class="number">-1</span>); <span class="comment">//将10个值为-1的元素添加到ilist尾部</span></span><br><span class="line">ilist.resize(<span class="number">5</span>); <span class="comment">//删除后面20个元素，保留前5个元素，分别都是42</span></span><br></pre></td></tr></table></figure>

<p><font color=red>如果缩小容器，则指被删除元素的迭代器指针引用都会失效。对vector,string,deque进行resize可能导致迭代器、指针、引用失效。</font></p>
<p><strong><font color=red>不要保存end返回的迭代器</font></strong><br>因为在删除或插入vector、string或deque之外任意位置的元素后，end迭代器总会失效。</p>
<table>
<thead>
<tr>
<th></th>
<th>管理容量的成员函数</th>
</tr>
</thead>
<tbody><tr>
<td>c.shrink_to_fit()</td>
<td>将capacity()减小为size()大小。只适用于vector、string、deque。</td>
</tr>
<tr>
<td>c.capacity()</td>
<td>不重新分配内存空间的情况下，c可以保存多少元素。只适用于vector和string</td>
</tr>
<tr>
<td>c.recerve(n)</td>
<td>分配至少能容纳n个元素的空间（通常会更大）</td>
</tr>
<tr>
<td><font color=red>调用resize永远不会减少容器占用空间，resize只改变容器中元素个数，不改变容器容量。如果要减小，用shrink_to_fit()（不保证一定退回）。</font></td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="comment">//size为0，capacity依赖于具体实现</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;ivec size:&quot;</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;ivec capacity:&quot;</span> &lt;&lt;ivec.capacity() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加24个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != <span class="number">24</span>; ++ix)&#123;</span><br><span class="line">    ivec.push_back(ix);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//size=24，capacity=32</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;ivec size:&quot;</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;ivec capacity:&quot;</span> &lt;&lt;ivec.capacity() &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p><font color=darkorange>vector的一个内存分配策略是，每次需要分配新的内存空间时，将当前容量翻倍。（不同实现不一样）</font></p>
<h3 id="string的特殊操作"><a href="#string的特殊操作" class="headerlink" title="string的特殊操作"></a>string的特殊操作</h3><table>
<thead>
<tr>
<th></th>
<th>string的特殊的构造方法</th>
</tr>
</thead>
<tbody><tr>
<td>string s(cp, n)</td>
<td>s是cp数组的前n个元素的拷贝。cp至少有n个元素。</td>
</tr>
<tr>
<td>string s(s2, pos)</td>
<td>s是s2的pos下标开始的字符的拷贝。若pos&gt;s2.size(),构造函数未定义。</td>
</tr>
<tr>
<td>string s(s2, pos2, len)</td>
<td>s是s2从下标pos2开始的len个字符的拷贝，不管len是多少，之多拷贝s2.size()-pos2个字符。</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cp = <span class="string">&quot;Hello World!!&quot;</span>;<span class="comment">//以空字符结束的数组</span></span><br><span class="line"><span class="keyword">char</span> noNull[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;; <span class="comment">//不是以空字符结束</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cp)</span></span>; <span class="comment">//拷贝cp中的字符，直到遇到空字符结尾。</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(noNull)</span></span>; <span class="comment">//未定义，noNull不是以空字符结尾</span></span><br></pre></td></tr></table></figure>
<p><strong>改变string的其他方法</strong><br>s.substr(pos, n)<br>返回一个string，包含从pos开始的n个字符的拷贝。如果开始位置pos超出string大小，则抛出out_of_range异常。</p>
<p>string除了接收迭代器版本的insert和erase之外，还提供下标版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.insert(s.size(), <span class="number">5</span>, <span class="string">&#x27;!&#x27;</span>); <span class="comment">//s末尾插入5个感叹号</span></span><br><span class="line">s.erase(s.size() - <span class="number">5</span>, <span class="number">5</span>); <span class="comment">//从s删除最后5个字符</span></span><br></pre></td></tr></table></figure>
<p>还有C风格字符串数组的insert和assign。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cp = <span class="string">&quot;Stately, plump Buck&quot;</span>;</span><br><span class="line">s.assign(cp, <span class="number">7</span>); <span class="comment">//赋予s指针cp开始的7个字符</span></span><br><span class="line">s.insert(s.size(), cp + <span class="number">1</span>); <span class="comment">//s=&quot;Stately, plump Buck&quot;</span></span><br></pre></td></tr></table></figure>
<p>此外还有两个额外的成员函数，append和replace。<br>append在字符串末尾添加字符串。replace在指定位置替换字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello world!&quot;</span>)</span></span>;</span><br><span class="line">s.append(<span class="string">&quot;good.&quot;</span>); <span class="comment">//s=&quot;hello world!good.&quot;</span></span><br><span class="line">a.repalce(<span class="number">6</span>, <span class="number">5</span>, <span class="string">&quot;jack&quot;</span>); <span class="comment">//s=&quot;hello jack!good.&quot; 也就是说替换字符串的长度与被替换字符串的长度不需要一样。</span></span><br></pre></td></tr></table></figure>
<p><strong>string的搜索操作</strong></p>
<p>每个搜索操作都返回一个string::size_type值，表示匹配位置的下标。如果搜索失败，则返回名为string::npos的static成员。npos是一个unsigned类型的。<br>||string的搜索操作|<br>|-|-|<br>|s.find(args)|查找s中args第一次出现的位置|<br>|s.rfind(args)|查找s中 args最后依次出现的位置|<br>|s.find_first_of(args)|在s中查找args中任意一个字符第一次出现的位置|<br>|s.find_last_of(args)|在s中查找args中任意一个字符第一次出现的位置|<br>|s.find_first_not_of(args)|在s中查找第一个不在args中的字符|<br>|s.find_last_not_of(args)|在s中查找最后一个不在args中的字符|<br>|args必须是以下形式之一||<br>|c, pos|从s中位置pos开始查找字符c。|<br>|s2, pos|从s中位置pos开始查找字符串s2。|<br>|cp, pos|在s中pos开始查找cp指向的以空字符结尾的C风格字符串|<br>|cp, pos, n|在s中pos开始查找cp指向的以空字符结尾的C风格字符串的前n个字符|</p>
<p><strong>字符串比较函数</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>s.compare()的集中参数形式</th>
</tr>
</thead>
<tbody><tr>
<td>s2</td>
<td>比较s与s2</td>
</tr>
<tr>
<td>pos1, n1, s2</td>
<td>将s中从pos1开始的n1个字符与s2比较</td>
</tr>
<tr>
<td>pos1, n1n s2, pos2, n2</td>
<td>将s中从pos1开始的n1个字符与s2中从pos2开始的n2个字符进行比较</td>
</tr>
<tr>
<td>cp</td>
<td>比较s与cp指向的字符串数组</td>
</tr>
<tr>
<td>pos1, n1, cp</td>
<td>将s中从pos1开始的n1个字符与cp指向的字符串数组比较</td>
</tr>
<tr>
<td>pos1, n1, cp, n2</td>
<td>将s中pos1开始的n1个字符与指针指向的地址开始的n2个字符串进行比较</td>
</tr>
</tbody></table>
<p><strong>string与数值之间的转换</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">50</span>;</span><br><span class="line"><span class="built_in">string</span> s = to_string(i); <span class="comment">//将数值型转换成string</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th></th>
<th>string与数值之间的转换</th>
</tr>
</thead>
<tbody><tr>
<td>stoi(s, p, b),stol(s, p, b), stoul(s, p, b),stoll(s, p, b), stoull(s, p, b)</td>
<td>返回s的起始字串的数值返回值类型分别是int,long,unsigned long, long long,unsigned long long，b表示转换所用基数，默认10进制。p是size_t指针，用来保存第一个非数值字符下标，默认为0</td>
</tr>
<tr>
<td>stof(s, p), stod(s, p), stold(s, p)</td>
<td>返回s的起始字串（表示浮点数内容的）数值。</td>
</tr>
</tbody></table>
<h2 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h2><p>一个容器适配器接受一种已有类型，使其行为看起来像另一种不同的类型。<br>stack, queue, priorty_queue</p>
<table>
<thead>
<tr>
<th></th>
<th>所有容器适配器都支持的操作和类型</th>
</tr>
</thead>
<tbody><tr>
<td>size_type</td>
<td>一种类型，足以保存当前类型的最大对象大小</td>
</tr>
<tr>
<td>value_type</td>
<td>元素类型</td>
</tr>
<tr>
<td>container_type</td>
<td>实现该适配器的底层容器类型</td>
</tr>
<tr>
<td>A a;</td>
<td>创建一个空的适配器</td>
</tr>
<tr>
<td>A a(c);</td>
<td>创建一个适配器a，带有容器c的一个拷贝。</td>
</tr>
<tr>
<td>==、!=、&lt;、&lt;=、&gt;、&gt;=</td>
<td>每个适配器都支持所有关系运算符</td>
</tr>
<tr>
<td>a.empty()</td>
<td>返回是否为空</td>
</tr>
<tr>
<td>a.size()</td>
<td>返回a中元素数目</td>
</tr>
<tr>
<td>swap(a, b),a.swap()</td>
<td>交换a,b内容，必须具有相同类型且底层容器类型也必须相同</td>
</tr>
</tbody></table>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;deq = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s</span><span class="params">(dep)</span></span>;<span class="comment">//用容器deque对象来初始化stack对象。</span></span><br></pre></td></tr></table></figure>

<p><strong>默认情况下，stack和queue是基于deque实现的，priorty_queue是基于vector实现的。</strong><br>stack只要求push_back,pop_back,back操作，所以可以使用除array和forward_list之外的任意顺序容器实现。queue要求back,push_back,front,push_front，因此可以基于deque和list，但不能基于vector。priority_queue除了要求front,back,push_back之外还要求随机访问，所以可以基于vector和deuqe，但不能基于list。</p>
<p>这是默认情况，我们也可以在创建一个适配器时，指定一个命名的顺序容器，来重载默认的容器类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector上实现栈</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; int_stk;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; dq = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span> &#125;; <span class="comment">//默认的stack是基于deque的</span></span><br><span class="line"><span class="function"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="title">s0</span><span class="params">(dq)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s0.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//size=6</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line">stack&lt;int, vector&lt;int&gt;&gt; s2(v); //将stack重载为基于vector的</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s2.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//size=4</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200511215546218.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDMxMzk0MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200511215612374.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDMxMzk0MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到，stack s0和s2是基于不同容器构造的。</p>
<table>
<thead>
<tr>
<th></th>
<th>stack特有的操作</th>
</tr>
</thead>
<tbody><tr>
<td>s.pop()</td>
<td>删除栈顶元素，但不返回元素。</td>
</tr>
<tr>
<td>s.push(item)</td>
<td>压栈</td>
</tr>
<tr>
<td>s.emplace(args)</td>
<td>将args压栈</td>
</tr>
<tr>
<td>s.top()</td>
<td>返回栈顶元素，但不将元素弹出栈。</td>
</tr>
<tr>
<td><font color=darkorange>每个容器适配器都定义了自己的特殊操作，只可以使用适配器操而不能使用底层容器的操作。</font></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>队列适配器特有操作</th>
</tr>
</thead>
<tbody><tr>
<td>q.pop()</td>
<td>弹出queue的首元素或者priority_queue的最高优先级元素，但不返回此元素。</td>
</tr>
<tr>
<td>q.front()</td>
<td>返回首元素或者尾元素，但不删除元素</td>
</tr>
<tr>
<td>q.back()</td>
<td>只适用于queue</td>
</tr>
<tr>
<td>q.top()</td>
<td>返回最高优先级元素，但不删除元素</td>
</tr>
<tr>
<td>q.push(item); q.emplace(args)</td>
<td>在queue的末尾或者priority_queue的适当位置创建一个元素，其值为item，或者为args</td>
</tr>
</tbody></table>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-IO库" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>很久不学C++，不少东西都变得很模糊，之前上课老师讲的内容其实很少，很多特性没有介绍，知识体系不够完整。所以打算系统地自学，我知道这将是很漫长的一段自学之路，我也不确定能否坚持完成，暂且就先且行且记录吧。我用的是目前最新的第五版，基于C++11标准的，介绍很多现代C++的新特性。</p>
<p>由于之前学习过，而且个人比较喜欢按模块来学习，所以并不是按照书本的顺序来讲，而是穿插着来学。由于还要帮老师搬砖，时间有限，不定期更，先记录着，之后可能的话再按顺序整理成一个合集吧。。<br>@[toc]</p>
<h1 id="IO库"><a href="#IO库" class="headerlink" title="IO库"></a>IO库</h1><h3 id="IO类"><a href="#IO类" class="headerlink" title="IO类"></a>IO类</h3><p>| IO库类型和头文件|<br>|–|–|</p>
<table>
<thead>
<tr>
<th>头文件</th>
<th>类型</th>
</tr>
</thead>
<tbody><tr>
<td>iostream</td>
<td>istream,wistream从流读取数据 <br>ostream,wostream向流写入数据<br>iostream,wiostream读写流</td>
</tr>
<tr>
<td>fstream</td>
<td>ifstream,wifstream从文件读取数据<br>ofstream,wofstream向文件写入数据<br>fstream,wfstream 读写文件</td>
</tr>
<tr>
<td>sstream</td>
<td>istringstream,wistringstream从string读取数据<br>ostringstream,wostringstream向string写入数据<br>stringstream,wstringstream读写string</td>
</tr>
<tr>
<td>其中前缀为w的为宽字符版本。ifstream和istringstream都继承自istream，也就是说可以像使用istream对象一样来使用ifstream和istringstream对象。</td>
<td></td>
</tr>
</tbody></table>
<p><strong>IO对象无拷贝或赋值</strong><br>不能拷贝或者对IO对象赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2; <span class="comment">//错误，不能对流对象赋值</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(ofstream)</span></span>; <span class="comment">//错误，不能初始化ofstream参数</span></span><br><span class="line">out2 = out3(out2); <span class="comment">//错误不能拷贝流对象 </span></span><br></pre></td></tr></table></figure>
<p>由于不能拷贝流对象，所以函数形参或者返回值不能为流类型，通常以引用方式传递和返回一个流，而且不能是const引用。比如重载&lt;&lt;操作符时，其参数和返回值是流引用。</p>
<p><strong>刷新输出缓冲区</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hi&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出hi和一个换行，然后刷新输出缓冲区</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hi&quot;</span> &lt;&lt; flush; <span class="comment">//输出hi,然后刷新缓冲区，但不输出任何额外字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hi&quot;</span> &lt;&lt; ends; <span class="comment">//输出hi和一个空字符，然后刷新缓冲区</span></span><br></pre></td></tr></table></figure>
<p>unitbuf操纵符，使用该操纵符后，所有的每次操作都会执行flush操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf; <span class="comment">//所有输出操作后都会立刻刷新缓冲区</span></span><br><span class="line"><span class="comment">//期间任何输出操作都会立刻刷新</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf; <span class="comment">//恢复到正常刷新模式</span></span><br></pre></td></tr></table></figure>
<p><strong>关联输入和输出流</strong><br>当一个输入流被关联到输出流时，任何从输入流读取数据的操作都会先刷新关联的输出流，标准库将cout和cin关联在一起，也就是说</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; ival;</span><br></pre></td></tr></table></figure>
<p>会导致cout缓冲立刻被刷新。<br>tie()有两个版本，一个不带参数，返回指向输出流的指针，如果对象当前未关联到输出流则返回空指针。第二个版本接收一个指向ostream的指针，将自己关联到该输出流。即，x.tie(&amp;o)将流x关联到输出流o。</p>
<h3 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h3><p>关于文件输入出，可以用&lt;&lt;和&gt;&gt;读写文件，也可以用getline从一个ifstream读取数据。<br><strong>fstream特有操作</strong></p>
<table>
<thead>
<tr>
<th>fstream fstrm</th>
<th>创建一个未绑定的文件流，fstream是头文件fstream中定义的一个类型</th>
</tr>
</thead>
<tbody><tr>
<td>fstream fstrm(s, mode)</td>
<td>创建一个fstream,并按指定mode打开名为s的文件，s可以是string类型或者是c风格字符串指针</td>
</tr>
<tr>
<td>fstrm.open(s)</td>
<td>打开名为s的文件，并将文件与fstrm绑定，默认mode依赖于fstream的类型，返回void</td>
</tr>
<tr>
<td>fstrm.close()</td>
<td>关闭于fstrm绑定的文件，返回void</td>
</tr>
<tr>
<td>fstrm.is_open()</td>
<td>返回bool，指出于fstrm关联的文件是否成功打开尚且未关闭</td>
</tr>
</tbody></table>
<p>文件模式</p>
<table>
<thead>
<tr>
<th>in</th>
<th>以读方式打开</th>
</tr>
</thead>
<tbody><tr>
<td>out</td>
<td>以写方式打开</td>
</tr>
<tr>
<td>app</td>
<td>每次写操作均定位到文件尾</td>
</tr>
<tr>
<td>ate</td>
<td>打开文件后立即定位到文件尾</td>
</tr>
<tr>
<td>trunc</td>
<td>截断文件</td>
</tr>
<tr>
<td>binary</td>
<td>以2进制方式进行IO</td>
</tr>
</tbody></table>
<ul>
<li>只可以对ofstream和fstream对象设置out模式。</li>
<li>同理，只可以对ifstream和fstream对象设置in模式。</li>
<li>只有当out被设定时才能设定trunc模式。</li>
<li>只要trunc模式未被设定，就可以设定app模式，在app模式下，即使没有显式指定out模式，文件也总是以输出方式被打开。</li>
<li>默认情况下，即使没有指定trunc，以out模式打开的文件也会被截断，如果要保留以out模式打开的文件内容，必须同时指定app模式或者in模式。</li>
<li>ate和binary可以用于任何类型文件流对象。</li>
<li><strong>ifstream关联的文件默认以in模式打开。ofstream关联的文件默认以out模式打开，会丢失文件内容，唯一方式保存文件内容是同时指定app模式或in模式保存内容。fstream关联的文件默认以out 和in 模式打开。</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;file1&quot;</span>)</span></span>; <span class="comment">//隐含以输出格式打开并截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out1</span><span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out)</span></span>;<span class="comment">//隐含截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">&quot;file1&quot;</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">//显式指定app模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">&quot;file2&quot;</span>, ofstream::app)</span><span class="comment">//显示保存文件内容</span></span></span><br></pre></td></tr></table></figure>

<h3 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h3><p><strong>stringstream特有操作</strong></p>
<table>
<thead>
<tr>
<th>sstreeam strm</th>
<th>strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的某一类型</th>
</tr>
</thead>
<tbody><tr>
<td>sstream strm(s)</td>
<td>strm是一个保存string s的一个sstream对象</td>
</tr>
<tr>
<td>strm.str()</td>
<td>返回strm流中保存的string的拷贝</td>
</tr>
<tr>
<td>strm.str()</td>
<td>将string s拷贝到strm中，返回void</td>
</tr>
</tbody></table>
<p><strong>使用istringstream</strong><br>首先定义一个结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line">	<span class="built_in">string</span> name;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;phones;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>程序读取数据文件，创建一个PersonInfo的vector。vector中每个元素对应文件中的一条记录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line, word; <span class="comment">//分别保存来自输入的一行和电话号码</span></span><br><span class="line"><span class="built_in">vector</span>&lt;PersonInfo&gt;people;</span><br><span class="line"><span class="comment">//逐行从输入读取数据，直到cin遇到文件尾或其他错误</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))&#123;</span><br><span class="line">	PersonInfo info;</span><br><span class="line">	<span class="function"><span class="built_in">istringstream</span> <span class="title">record</span><span class="params">(line)</span></span>; <span class="comment">//将记录绑定到刚读入的行</span></span><br><span class="line">	record &gt;&gt; info.name;</span><br><span class="line">	<span class="keyword">while</span>(record &gt;&gt; word)&#123;</span><br><span class="line">		info.phones.push_back(word);</span><br><span class="line">	&#125;</span><br><span class="line">	people.push_back(info);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完待续。。。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-IO%E5%BA%93/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-函数" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h3 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a><strong>局部对象</strong></h3><p>局部变量会隐藏外层作用域中同名的其他所有声明。<br><strong>局部静态对象</strong><br>在程序的执行路径第一次经过对象定义语句时初始化，并直到程序终止才会被销毁，即使对象所在的函数结束执行也不会对它有影响。<br>如果局部静态变量没有显式的初始化，它将会被进行值初始化，内置类型的局部静态变量初始化为0.</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a><strong>参数传递</strong></h3><p><strong>传值参数</strong></p>
<p>初始化一个非引用类型的变量时，初始值被拷贝给变量，因此对变量的改动不会影响初始值。</p>
<p><strong>指针形参</strong></p>
<p>传递指针形参时，拷贝的是指针的值，也就是地址。这是两个不同的指针。通过指针可以间接访问所指向的对象并修改对象的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>, i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;n, *q = &amp;i;</span><br><span class="line">*p = <span class="number">2</span>; <span class="comment">//n的值变为2</span></span><br><span class="line">p = q; <span class="comment">//p指向了i</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> *ip)</span></span>&#123;</span><br><span class="line">    *ip = <span class="number">0</span>;<span class="comment">//改变了ip所指向的对象的值，也就是i的值</span></span><br><span class="line">    ip = <span class="number">0</span>; <span class="comment">//只改变了ip的局部拷贝，实参未被改变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line">reset(&amp;i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出结果是i=0.</span></span><br></pre></td></tr></table></figure>
<p><strong>传引用参数</strong></p>
<p>使用引用传递参数可以避免拷贝，减小计算消耗。此外，还有一些类类型不支持拷贝操作（IO类型等），只能通过引用形参访问该类型对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123; <span class="comment">//若无需改变引用形参的值，最好将其声明为常量引用</span></span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>const形参和实参</strong></p>
<p>顶层const作用于对象本身。底层const作用于对象（通常指针）所指向的对象。<br>与其他初始化一样，用实参初始化形参时，会忽略掉顶层const。也就是说形参有顶层const时，传给他常量对象或者非常量对象都是可以的。<br>忽略顶层const可能会产生一些意想不到的问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;...&#125; <span class="comment">//func能读取i，但不能写</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;...&#125; <span class="comment">//错误，重复定义了func，因为顶层const被忽略了。</span></span><br></pre></td></tr></table></figure>
<p><strong>数组形参</strong></p>
<p>数组的特殊性质：</p>
<ul>
<li>不允许拷贝数组</li>
<li>使用数组会将其转换成指针<br>所以向一个函数传递数组时，其实传递的是数组首元素的指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种等价形式，其形参都是const int *</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *)</span></span>; <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>; <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>; <span class="comment">//这里的维度表示的是我们希望数组有多少维度，实际不一定</span></span><br></pre></td></tr></table></figure>
数组引用形参<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>int &amp;arr[10]; //这是一个包含10个引用的数组<br>int (&amp;arr)[10]; //这是一个指向包含10个整数的整型数组的引用</p>
</blockquote>
</li>
</ul>
<h3 id="main处理命令行参数"><a href="#main处理命令行参数" class="headerlink" title="main处理命令行参数"></a><strong>main处理命令行参数</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *agrv[])</span></span>&#123;...&#125; <span class="comment">//argv是一个数组，其中的每个元素是指向一个C风格字符串的指针， argc表示数组中字符串的数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><font color=red>argv[0]是程序的名字，可选的实参从argv[1]开始。</font></p>
<h3 id="含有可变形参的函数"><a href="#含有可变形参的函数" class="headerlink" title="含有可变形参的函数"></a><strong>含有可变形参的函数</strong></h3><ul>
<li>如果所有形参类型相同，可以传递一个名为initializer_list的标准库类型。</li>
<li>如果实参类型不一样，可以编写可变参数模板来实现可变形参的函数。</li>
<li>特殊形参类型，即省略符。一般只用于与C函数的交互接口程序。</li>
</ul>
<p><strong>initializer_list</strong></p>
<p>initializer_list定义在同名头文件中。<br>||initializer_list提供的操作|<br>|-|-|<br>|initializer_list<T> lst;|默认初始化T类型的空列表|<br>|initializer_lsit<T> lst{a, b, c, …};|lst的元素和初始化列表一样多，lst元素是对应初始值的拷贝，列表中的元素是const.|<br>|lst2(lst);  lst2 = lst|拷贝或者赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后原始列表和副本共享元素|<br>|lst.size();|lst中的元素数量|<br>|lst.begin();|返回指向lst的首元素指针|<br>|lst.end();|返回指向lst尾元素后一个位置的指针。|</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error_msg</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.begin(); beg != il.end(); ++beg)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *beg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> expect = <span class="string">&quot;hhh&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> actual;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; actual;</span><br><span class="line"><span class="keyword">if</span>(expect != actual)&#123;</span><br><span class="line">    <span class="comment">//如果向initializer_list形参中传递一个值的序列，必须把序列放在一个花括号内。</span></span><br><span class="line">    error_msg(&#123;<span class="string">&quot;functionX&quot;</span>, expect, actual&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    error_msg(&#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;ok&quot;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，含有initializer_list的函数还可以拥有其他形参。</p>
<p><strong>省略符形参</strong></p>
<p>省略符形参会调用varargs的C标准库功能。<font color=red>…只能用于C和C++都通用的类型，对于大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</font><br>省略符形参只能出现在形参列表的最后位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(param_list, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p><font color=red><strong>不要返回局部对象的引用或者指针。</strong></font></p>
<p>因为函数返回后，局部对象(静态局部变量除外)的存储空间就会被释放掉，也就是说局部变量的引用将指向无效的地址。</p>
<h3 id="返回类类型的函数和调用运算符"><a href="#返回类类型的函数和调用运算符" class="headerlink" title="返回类类型的函数和调用运算符"></a><strong>返回类类型的函数和调用运算符</strong></h3><p>如果函数返回的是指针、引用或者类的对象，那么可以使用函数调用的结果来访问对象的成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用返回的string对象的size成员</span></span><br><span class="line"><span class="keyword">auto</span> sz = shorterString(s1, s2).size();</span><br></pre></td></tr></table></figure>
<p><strong>列表初始化返回值</strong></p>
<p>C++11新标准中，函数可以返回花括号包围的值的列表。<br>可以像这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">process</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//expected, actual是string对象</span></span><br><span class="line">    <span class="keyword">if</span>(expect.empty())&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (expect == actual)&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>, <span class="string">&quot;ok&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;functionX&quot;</span>, expect, actual&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color=red>如果函数返回的是内置类型,则花括号包围的列表最多包含一个值。</font></p>
<p><strong>返回数组指针</strong></p>
<p>返回函数指针主要有四种方法：一般的声明方式、使用类型别名、使用尾置返回类型以及使用decltype。</p>
<p><strong>使用类型别名</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>]; <span class="comment">//arrT是类型别名，表示的是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span> [<span class="number">10</span>]; <span class="comment">//等价形式</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>; <span class="comment">//返回指向含有10个整数的数组的指针。</span></span><br></pre></td></tr></table></figure>

<p><strong>一般的声明方式</strong></p>
<p>如果要定义返回数组指针的函数，数组的维度必须跟在函数名字之后，且放在形参列表之后。<br>type(*function(parameter_list))[dimension]</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>]; <span class="comment">//返回指向包含10个int元素的数组的指针</span></span><br><span class="line">int *func(int i)[10]; //没有外层括号，返回的则是包含10个int指针的数组</span><br></pre></td></tr></table></figure>
<p><strong>使用尾置返回类型</strong></p>
<p>使用尾置返回类型可以简化上述声明。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表明函数接收一个int实参，返回一个指针，该指针指向含有10个整数的的数组</span></span><br><span class="line">auto func(int i)-&gt;int (*)[10];</span><br></pre></td></tr></table></figure>
<p><strong>使用decltype</strong></p>
<p>若直到函数返回的指针指向哪个数组，就可以使用decltype声明返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i)&#123; <span class="comment">//decltype不负责把数组类型转化成对应指针，所以arrPtr前面要加上*</span></span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;even : &amp;odd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小练习：编写一个函数声明，使其返回数组的引用，该数组包含10个string对象。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> (&amp;func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//使用类型别名</span></span><br><span class="line"><span class="keyword">using</span> s10 = <span class="built_in">string</span> [<span class="number">10</span>]；<span class="comment">//等价于typedef string s10[10];</span></span><br><span class="line">s10 &amp;func(<span class="keyword">int</span> i);</span><br><span class="line"><span class="comment">//尾置返回类型</span></span><br><span class="line">auto func(int i)-&gt;string (&amp;)[10];//这样理解，首先是一个引用&amp;，这个引用绑定到string[10]数组中。</span><br><span class="line"><span class="comment">//s使用decltype</span></span><br><span class="line"><span class="built_in">string</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">decltype</span>(s) &amp;func(<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure>
<p><strong>main函数的返回值</strong></p>
<p>main函数允许没有return语句直接结束，编译器会隐式地插入一条返回0的语句。<br>函数递归调用消耗栈空间。main函数不能调用自己。</p>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a><strong>函数重载</strong></h3><p>main函数不能重载。<br>一个作用域内，函数名字相同，形参列表、返回值不同则是函数重载。</p>
<p><strong>const形参的问题</strong></p>
<p>顶层const不影响传入函数的对象，也就是说无法将含有顶层const的形参和不含有顶层const的形参区分开来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>;<span class="comment">// 重复声明了func</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptr</span><span class="params">(<span class="keyword">int</span>* p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ptr</span><span class="params">(<span class="keyword">int</span>* <span class="keyword">const</span> p)</span></span>; <span class="comment">//重复声明了ptr</span></span><br></pre></td></tr></table></figure>
<p>对于接收引用和指针的函数来说，对象是常量还是非常量，对应的形参不同</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *p)</span></span>;<span class="comment">//函数作用于指向int的指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *p)</span></span>; <span class="comment">//新函数，作用域指向常量的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ref</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span>; <span class="comment">//函数作用于int引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ref</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span>;<span class="comment">//新函数，作用于常量引用</span></span><br></pre></td></tr></table></figure>
<p><font color=darkorange>当传递一个非常量对象或者指向非常量对象的指针时，会优先调用非常量版本函数。</font></p>
<p><strong>const_cast和重载</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数和返回类型都是const string&amp;。函数传入两个非常量string后，得到的是const string的引用，这样一来，s1和s2就不可写了，这会影响后面程序。所以，需要一个新的函数，在它的实参不是常量时，得到的是一个非常量引用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">shorterString</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = shorterString(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s1), <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来，传入2个非常量string，比较得到较短的对象的非常量引用，这样显然是安全的。</p>
<p><font color=red>在C++中，名字查找发生在类型检查之前。</font></p>
<h3 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">string</span>::size_type sz;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="keyword">char</span> backgrnd = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>一旦某个形参被赋予了默认值，后面的所有形参必须有默认值。</p>
<p><strong>默认实参声明</strong><br>在给定作用域中，一个形参只能被赋予一次默认实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示高度和宽度没有默认实参</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="comment">//不能修改一个已经存在的默认值</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;<span class="comment">//错误，重复声明了</span></span><br><span class="line"><span class="comment">//但是可以像下面这样添加默认实参,因为第三个参数已经有了默认实参，所以符合之前的标准。</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">40</span>, <span class="keyword">char</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>默认实参初始值</strong></p>
<p>局部变量不能作为默认实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//wd, def, ht的声明必须在函数之外</span></span><br><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="keyword">char</span> = def)</span></span>;<span class="comment">//声明</span></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="built_in">string</span> window = screen(); <span class="comment">//调用screen(ht(),80,&#x27; &#x27;); </span></span><br></pre></td></tr></table></figure>
<p>用作默认实参的名字在函数声明所在的作用域内解析，而名字的求值过程发生在函数调用时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    def = <span class="string">&#x27;*&#x27;</span>; <span class="comment">//改变了默认实参的值</span></span><br><span class="line">    sz wd = <span class="number">100</span>; <span class="comment">//隐藏了外层定义的wd，但没有改变默认实参</span></span><br><span class="line">    window = screen(); <span class="comment">//调用的是screen(ht(), 80, &#x27;*&#x27;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数可以避免函数调用的开销。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="built_in">string</span> &amp; <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp; s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.size() &lt; s2.size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="constexpr函数"><a href="#constexpr函数" class="headerlink" title="constexpr函数"></a>constexpr函数</h3><p>函数的返回类型和所有形参类型都是字面值类型，函数体中必须有且只有一条return语句。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> foo = new_sz(); <span class="comment">//正确，foo是一个常量表达式</span></span><br></pre></td></tr></table></figure>
<p>编译器在编译时能够验证函数的返回值类型。</p>
<p>constexpr函数的返回值不一定是一个常量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果arg是常量表达式，则scale(arg)也是常量表达式,反之则不然</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> new_sz() * cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[scale(<span class="number">2</span>)]; <span class="comment">//正确，scale(2)是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> arr2[scale(i)]; <span class="comment">//错误，scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，把内联函数和constexpr函数放在头文件中。</p>
<p><strong>调试帮助</strong></p>
<p>assert预处理宏，定义在cassert头文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">assert(s.size() &gt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>assert的行为依赖于NDEBUG预处理变量的状态。如果定义了NDEBUG，则assert什么也不做，默认状态下没有定义NDEBUG，assert将执行运行时的检查。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC -D NDEBUG main.c</span><br></pre></td></tr></table></figure>
<p>等价于在main.c文件开始写#define NDEBUG。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> a[], <span class="keyword">size_t</span> size)</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="comment">//__func__是编译器定义的一个局部静态变量，用于存放函数名字,是一个const char的静态数组。</span></span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; __func__ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>__ FILE __ 存放文件名的字符串字面值</li>
<li>__ LINE __ 存放当前行号的整型字面值</li>
<li>__ TIME __ 存放文件编译时间的字符串字面值</li>
<li>__ DATE __ 存放文件编译日期的字符串字面值</li>
</ul>
<h3 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h3><p><strong>const实参</strong></p>
<p>如果重载函数的区别是形参的引用类型是否引用了const，或者指针的形参是否指向了const，则调用时编译器通过实参是否是常量来决定使用哪个函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;i)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">f(a); <span class="comment">//调用f(const int &amp;i),不能把普通引用绑定到const对象上。</span></span><br><span class="line">f(b); <span class="comment">//调用f(int &amp;i)</span></span><br></pre></td></tr></table></figure>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><ul>
<li>函数的类型由其返回值类型和形参类型共同决定。</li>
<li>函数是不能直接返回函数的，也不能直接返回数组。(只能返回函数指针或数组指针。)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">shorterString</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
该函数类型是bool (const string&amp;, const string&amp;)。声明一个函数指针，则只需要将函数名替换成指针即可。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未初始化的指针</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;) <span class="comment">//指针的括号不能省，如果省略，pf就是一个返回值为bool*的函数</span></span><br></pre></td></tr></table></figure>
把函数名作为一个值使用时，跟数组一样，都会自动地转换成指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf = shorterString;</span><br><span class="line">pf = &amp;shorterString; <span class="comment">//两种形式等价</span></span><br></pre></td></tr></table></figure>
函数指针可以调用该函数，无需提前解引用指针。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = pf(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;wolrd!&quot;</span>);</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>);<span class="comment">//等价形式</span></span><br><span class="line"><span class="keyword">bool</span> b3 = shorterString(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world!&quot;</span>);</span><br></pre></td></tr></table></figure>
指向不同函数类型的指针不存在转换规则。也就是说函数指针指向的函数的类型必须与指针类型一致。</li>
</ul>
<p><strong>重载函数的指针</strong></p>
<p>指针类型必须与重载的函数中的某一个类型精确匹配。</p>
<p><strong>函数指针形参</strong></p>
<p>与数组类似，不能直接定义函数类型的形参，但是可以定义指向函数的指针类型的形参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2, <span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2, <span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以直接把函数当作实参使用，此时函数会被转换成函数指针。</span></span><br><span class="line">useBigger(s1, s2, shorterString);</span><br></pre></td></tr></table></figure>
<p><strong>返回指向函数的指针</strong></p>
<p>和数组类似，虽然不能直接返回函数，但可以返回指向函数的指针。<br>但是编译器不会自动将函数返回类型当成对应的指针类型处理。简便方式就是使用类型别名来声明返回函数指针的函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//F是函数类型</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//PF是指针类型</span></span><br><span class="line"><span class="function">PF <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确，PF是指向函数的指针，f1返回函数指针</span></span><br><span class="line"><span class="function">F <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//错误，F是函数类型，而函数f1不能返回一个函数</span></span><br><span class="line"><span class="function">F* <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">//正确，显式地指定返回类型是指向函数的指针。</span></span><br></pre></td></tr></table></figure>
<p>使用尾置返回类型声明返回函数指针的函数。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto f(int)-&gt;int(*)(int*, int);</span><br></pre></td></tr></table></figure>
<p>还可以直接声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>(*f(<span class="keyword">int</span>)) (<span class="keyword">int</span>*, <span class="keyword">int</span>); <span class="comment">//f(int)函数返回一个指向int(int*, int)类型函数的指针。</span></span><br></pre></td></tr></table></figure>

<p><strong>将auto和decltype用于函数指针类型</strong></p>
<p>如果明确知道返回的函数是哪一个，就可以使用decltype简化书写函数指针返回类型的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">sumLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span>::size_type <span class="title">largerLength</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *getFcn(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>
<p>时刻注意decltype()作用于函数时，返回的是函数类型，而非指针类型，所以需要在getFcn前加上*表示函数的返回值是函数指针。</p>
<p>还有，decltype(expr)作用于表达式时，只是推断表达式的类型，而不实际计算其运算结果。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E5%87%BD%E6%95%B0/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-C++Primer-表达式" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h4><p>当一个对象被用作右值的时候，用到的是对象的值(也就是内容)。而当对象被用作左值时，用到的是对象的本身(也就是内存)。<br>一般情况下，用到右值的地方可以用左值来代替，但不能用右值来代替左值。</p>
<h4 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h4><p>对于一个运算表达式，通常情况下不会明确其求值顺序，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = f1() * f2(); <span class="comment">//不确定是先计算f1还是f2</span></span><br></pre></td></tr></table></figure>
<p>如果表达式指向并修改了同一个对象，会产生未定义错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>&lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//未定义</span></span><br></pre></td></tr></table></figure>
<p>只有四种运算符明确了求值顺序：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>逻辑与 &amp;&amp;</td>
<td>先求左侧对象的值，只有左侧对象的值为真时才继续求右侧对象的值</td>
</tr>
<tr>
<td>逻辑或||</td>
<td>先求左侧运算对象的值，只有左侧运算对象的值为假时才会继续求右侧运算对象的值，即短路求值</td>
</tr>
<tr>
<td>条件运算符(cond? expr1: expr2)</td>
<td>先求cond的值，如果条件为真，对expr1求值并返回该值，否则对expr2求值并返回该值。</td>
</tr>
<tr>
<td>逗号运算符</td>
<td>首先对左侧表达式求值，将该结果丢掉，运算符真正结果是右侧表达式的值。</td>
</tr>
</tbody></table>
<p>取余运算%的运算对象必须是整数类型。</p>
<p><strong>递增递减运算符</strong></p>
<p>前置版本和后置版本<br>前置版本将运算对象+1(-1)，将改变后的对象作为求值结果，对象本身作为左值返回。<br>后置版本也会将运算对象+1(-1)，但求值结果是运算对象改变之前的那个值的副本，副本作为右值返回。<br><font color=red>除非必须，否则尽量使用前置版本的递增递减运算符</font>,因为对于复杂的类型迭代器来说，后置++(–)会创建副本，消耗资源。</p>
<p><strong>解引用运算符与递增运算符</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.begin();</span><br><span class="line"><span class="keyword">while</span>(pbeg != v.end() &amp;&amp; *pbeg &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pbeg++ &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//*pbeg++ == *(pbeg++)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为解引用运算符优先级较低，所以结果是pbeg的值+1，然后返回pbeg初始值的副本作为解引用的结果。</p>
<p><strong>成员访问运算符</strong></p>
<p>ptr-&gt;mem 等价于 (*p).mem</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;a string&quot;</span>, *p = &amp;s;</span><br><span class="line"><span class="keyword">auto</span> n = s.size();</span><br><span class="line">n = (*p).size(); <span class="comment">//解引用运算符优先级低于.运算符，所以要加上括号。</span></span><br><span class="line">n = p-&gt;size();</span><br></pre></td></tr></table></figure>
<p>这种情况是错误的，因为指针p没有size()成员函数，是它所指向的对象有size()成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*p.size(); <span class="comment">//错误</span></span><br><span class="line">p-&gt;size(); <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>
<p><strong>条件运算符 cond ? expr1 : expr2</strong><br>条件运算符优先级非常低，因此当一条长表达式中嵌套条件运算子表达式时，通常要在其两端加上括号。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; ((grade &gt; <span class="number">60</span>) ? <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;fail&quot;</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//正确，输出pass或者fail</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (grade &gt; <span class="number">60</span>) ? <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;fail&quot;</span> &lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出1或者0！</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; grade &gt; <span class="number">60</span> ? <span class="string">&quot;pass&quot;</span> : <span class="string">&quot;fail&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//错误，试图比较cout和60， 因为&lt;&lt; 返回值是cout</span></span><br></pre></td></tr></table></figure>

<p><strong>位运算符</strong></p>
<p>~, &lt;&lt;, &gt;&gt;, &amp;, |, ^</p>
<p><font color=red>注意区分位与&amp;和逻辑与&amp;&amp;，位或|和逻辑或||，位求反~和逻辑非!。</font></p>
<p><strong>sizeof运算符</strong><br>返回一条表达式或者一个类型名字所占用的字节数。满足右结合律，其值是一个size_t类型。<br>sizeof(type)、sizeof expr。其中第二种表达式只返回表达式结果类型的大小，而不计算其运算的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data); <span class="comment">//存储Sales_data类型对象所占的空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data; <span class="comment">//data的类型的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> p; <span class="comment">//指针所占空间的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p; <span class="comment">//p所指向的类型的空间大小，即sizeof(Sales_data)</span></span><br></pre></td></tr></table></figure>
<p>sizeof与*运算符的优先级一样，因为sizeof满足右结合律，所以sizeof *p等价于sizeof (*p)。<font color=red>sizeof的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为该指针并没有被用到。</font></p>
<p>此外还允许使用作用域运算符来获取类成员的大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> data.revenue; <span class="comment">//Sales_data的revenue成员的类型的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> Sales_data::revenue; <span class="comment">//等价形式</span></span><br></pre></td></tr></table></figure>
<p>对数组进行sizeof等价于对数组的每个元素分别进行sizeof之后取和，也就是说sizeof不会把数组转换成指针来运算。<br><font color=red>对string或者vector对象执行sizeof只会返回该类型固定部分的大小，不会计算对象中元素占用了多少空间。</font></p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="算数转换"><a href="#算数转换" class="headerlink" title="算数转换"></a>算数转换</h4><p>运算符的运算对象将转换成最宽的类型，如一个运算对象的类型是long double，则无论另一个类型是什么都会转换成long double。当表达式中既有浮点数也有整数时，整数值将转换成相应的浮点数类型。</p>
<p><strong>整型提升</strong><br>把小整数类型转换成较大的整数类型。多实践才能记住。</p>
<p><strong>数组转换成指针</strong><br>在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *p = ia; <span class="comment">//ia转换成指向数组首元素的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>指针的转换</strong><br>常量整数值0或者nullptr能转换成任意类型的指针。指向任意非常量的指针都能转换成void<em>。指向任意对象的指针都能转换成const void</em>。<br>转换成常量：允许将非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是如此。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = i; <span class="comment">//非常量转换成const int 的引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i; <span class="comment">//非常量的地址转换成const的地址</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = j, *q = p; <span class="comment">//错误，不允许const转换成非常量</span></span><br></pre></td></tr></table></figure>

<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>static_cast, dynamic_cast, const_cast, reinterpret_cast。<br><font color=darkorange>dynamic_cast</font>:支持运行时类型识别。<br><font color=darkorange>static_cast</font>:只要不包含底层const，都可以使用static_cast。运用static_cast可以将较大的类型赋值给较小的类型，不会出现警告信息。static_cast对于编译器无法自动执行的类型转换也非常有用。如static_cast可以找回存在于void*指针中的值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d = <span class="number">9</span>;</span><br><span class="line"><span class="keyword">void</span>* p = &amp;d; <span class="comment">//对于任意非常量对象的地址都能存入void*</span></span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);<span class="comment">//正确，将void*转换回初始指针类型</span></span><br></pre></td></tr></table></figure>
<p><font color=darkorange>const_cast</font>:只能改变运算对象的底层const，不能改变表达式的类型。将常量对象转换成非常量对象。常用于函数重载的上下文中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc);<span class="comment">//正确，但是通过p来写入值的话是未定义的行为。</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&gt;(pc); <span class="comment">//错误，const_cast只能改变常量属性。</span></span><br></pre></td></tr></table></figure>

<p><font color=darkorange>reinterpret_cast</font>:为运算对象的位模式提供较低层次上的重新解释。很危险，尽量避免使用。</p>
<h4 id="旧式的强制类型转换"><a href="#旧式的强制类型转换" class="headerlink" title="旧式的强制类型转换"></a>旧式的强制类型转换</h4><p>type(expr);<br>(type)expr;</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2020/12/01/C++Primer-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2020 JimmyTang
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: true
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="https://blog.csdn.net/weixin_40313940?spm=1001.2100.3001.5113" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">&lt;br&gt;&lt;br&gt;不知名国人&lt;br&gt;</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>